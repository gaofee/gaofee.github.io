import{ab as s,G as a,H as l,E as e,S as n,N as t,ac as r,W as d}from"./framework-251de721.js";const o={},c=r('<h1 id="学习目标" tabindex="-1"><a class="header-anchor" href="#学习目标" aria-hidden="true">#</a> 学习目标</h1><ul><li>能够知道架构的演进过程</li><li>能够知道什么是Spring Cloud</li><li>能够知道什么是Eureka以及安全</li><li>能够使用Eureka搭建单点和集群</li><li>能够知道什么是Consul以及如何安装和启动</li><li>能够使用Consul服务发现</li><li>能够知道什么是Nacos</li><li>能够使用Nacos搭建服务注册发现和配置中心</li><li>能够知道什么是Ribbon</li><li>能够使用Ribbon实现负载均衡</li></ul><h1 id="_1-初识spring-cloud" tabindex="-1"><a class="header-anchor" href="#_1-初识spring-cloud" aria-hidden="true">#</a> 1 初识Spring Cloud</h1><h2 id="_1-1-架构演进" tabindex="-1"><a class="header-anchor" href="#_1-1-架构演进" aria-hidden="true">#</a> 1.1 架构演进</h2><p><strong>1. 单体架构</strong></p><ul><li><p>单体架构简介</p><p>一个归档包（例如war格式或者Jar格式）包含了应用所有功能的应用程序，我们通常称之为单体应用。</p></li><li><p>一个归档包（例如war格式或者Jar格式）包含了应用所有功能的应用程序，我们通常称之为单体应用。</p></li></ul><p>架构单体应用的方法论，我们称之为单体应用架构，这是一种比较传统的架构风格,如下图：</p><img src="https://gaofee.cc/images/202303171135763.png" alt="monomer-architecture" style="zoom:67%;"><ul><li>单体架构不足</li></ul><p>​ 1、业务越来越复杂</p><p>应用的代码量越来越大，代码的可读性、可维护性和可扩展性下降，新人接手代码所需的时间成倍增加，业务扩展带来的代价越来越大。</p><p>​ 2、随着用户越来越多，程序承受的并发越来越高，单体应用的并发能力有限。</p><p>​ 3、测试的难度越来越大，单体应用的业务都在同一个程序中，随着业务的扩张、复杂度的增加，单体应用修改业务或者增加业务或许会给其他业务带来一定的影响，导致测试难度增加。</p><p><strong>2. SOA架构</strong></p><ul><li>SOA架构简介</li></ul><p>​ SOA（Service-Oriented Architecture，面向服务的架构）是一个组件模型，它将应用程序的不同功能单元（称为服务）进行拆分，并通过这些服务之间定义良好的接口和契约联系起来。</p><p>接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。</p><p>这使得构建在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。 ESB(Enterparise Servce Bus):企业服务总线，服务中介。主要是提供了一个服务于服务之间的交互。 ESB 包含的功能如：负载均衡，流量控制，加密处理，服务的监控，异常处理，监控告急等等。</p><img src="https://gaofee.cc/images/202303171135764.png" alt="soa-architecture" style="zoom:67%;"><ul><li>SOA架构不足</li></ul><p>​ 1、系统之间交互需要使用远程通信，接口开发增加工作量</p><p>​ 2、松耦合和敏捷性要求之间的权衡</p><p>​ 3、系统组件与其他组件进行通信，安全性难以保证</p><p>​ 4、跨系统集成问题</p><p><strong>3. 微服务架构</strong></p><ul><li>微服务简介</li></ul>',26),u={href:"http://martinfowler.com/articles/microservices.html%E7%AE%80%E5%8D%95%E5%9C%B0%E8%AF%B4,%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%98%AF%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E4%B8%8A%E7%9A%84%E4%B8%80%E7%A7%8D%E8%AE%BE%E8%AE%A1%E9%A3%8E%E6%A0%BC,%E5%AE%83%E7%9A%84%E4%B8%BB%E6%97%A8%E6%98%AF%E5%B0%86%E4%B8%80%E4%B8%AA%E5%8E%9F%E6%9C%AC%E7%8B%AC%E7%AB%8B%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%8B%86%E5%88%86%E6%88%90%E5%A4%9A%E4%B8%AA%E5%B0%8F%E5%9E%8B%E6%9C%8D%E5%8A%A1,%E8%BF%99%E4%BA%9B%E5%B0%8F%E5%9E%8B%E6%9C%8D%E5%8A%A1%E9%83%BD%E5%9C%A8%E5%90%84%E8%87%AA%E7%8B%AC%E7%AB%8B%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%AD%E8%BF%90%E8%A1%8C,%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E9%80%9A%E8%BF%87%E5%9F%BA%E4%BA%8EHTTP%E7%9A%84",target:"_blank",rel:"noopener noreferrer"},p=r(`<ul><li><p>微服务优势</p><p>1、可以用不同的语言或者语言不同版本开发不同模块</p><p>2、系统耦合性弱，其中一个模块有问题，可以通过“降级熔断”等手段来保证系统不血崩</p><p>3、可以独立上线，能够迅速响应需求</p><p>4、可以对不同模块用不同的集群策略，哪里慢集群哪里</p><p>5、智能端点与哑管道</p></li><li><p>微服务不足</p><p>1、运维成本大幅度上升</p><p>2、系统结构复杂，接口兼容多版本，开发难度大，</p><p>3、部署数量较多，服务治理成本高</p><p>4、分布式系统的复杂性（分布式事务）</p></li></ul><h2 id="_1-2-走进spring-cloud" tabindex="-1"><a class="header-anchor" href="#_1-2-走进spring-cloud" aria-hidden="true">#</a> 1.2 走进Spring Cloud</h2><p><strong>1. Spring Cloud与Spring Boot关系</strong></p><ul><li><p>Spring boot是 Spring 的一套快速配置脚手架可以基于spring boot 快速开发单个微服务；Spring Cloud是一个基于Spring Boot实现的云应用开发工具</p></li><li><p>Spring boot专注于快速、方便集成的单个个体，Spring Cloud是关注全局的服务治理框架；</p></li><li><p>Spring boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring Cloud很大的一部分是基于Spring boot来实现。</p></li><li><p>Spring boot可以离开Spring Cloud独立使用开发项目，但是Cloud离不开 boot，属于依赖的 关系</p></li></ul><img src="https://gaofee.cc/images/202303171135765.png" alt="relation" style="zoom:67%;"><p><strong>2. Spring Cloud简介</strong></p><p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简 化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、 断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><p><strong>3. 为什么选择Spring Cloud</strong></p><p>springcloud利用springboot的开发便利性巧妙地简化了分布式系统基础设施的开发，springcloud为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务返现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等 springcloud是分布式微服务架构下的一站式解决方案，开箱即用，是各个微服务架构落地技术的集合体，俗称微服务全家桶。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Spring Cloud好处简单总结：
1：云原生
2：开箱即用、快速启动
3：适用于各种环境
4：轻量级的组件
5：组件支持丰富，功能齐全
6：约定优于配置
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>4. 官方项目位置</strong></p>`,11),g={href:"https://spring.io/projects/spring-cloud",target:"_blank",rel:"noopener noreferrer"},v=r('<p><strong>5. 版本介绍</strong></p><p>Spring Cloud是一个由众多独立子项目组成的大型综合项目，每个子项目有不同的发行节奏，都维护着自己的发布版本号。Spring Cloud通过一个资源清单BOM（Bill of Materials）来管理每个版本的子项目清单。为避免与子项目的发布号混淆，所以没有采用版本号的方式，而是通过命名的方式。</p><p>这些版本名称的命名方式采用了伦敦地铁站的名称，同时根据字母表的顺序来对应版本时间顺序，比如：最早的Release版本：Angel，第二个Release版本：Brixton，然后是Camden、Dalston、Edgware，Finchley，Greenwich，目前最新的是Hoxton版本 <img src="https://gaofee.cc/images/202303171135766.png" alt="cloud-boot-version" style="zoom:67%;"></p><p>版本号解释(Spring Cloud)：</p><table><thead><tr><th>版本标志</th><th>含义</th></tr></thead><tbody><tr><td>SR</td><td>SR1表示第一个正式版本，同时标注GA(Generally Available)，稳定版</td></tr><tr><td>M stands for milestone</td><td>M版本，MileStone，M1表示第一个里程碑版本，一般同时标注PRE，表示预览版</td></tr><tr><td>Snapshot</td><td>快照版本，尝鲜版，随时可能修改</td></tr></tbody></table><ul><li><strong>通用软件版本阶段说明</strong>（包含但不限于Spring Cloud）</li><li>Alpha版: 此版本表示该软件在此阶段主要是以实现软件功能为主，通常只在软件开发者内部交流，一般而言，该版本软件的Bug较多，需要继续修改。</li><li>Beta版: 该版本相对于α版已有了很大的改进，消除了严重的错误，但还是存在着一些缺陷，需要经过多次测试来进一步消除，此版本主要的修改对像是软件的UI。</li><li>RC版: 该版本已经相当成熟了，基本上不存在导致错误的BUG，与即将发行的正式版相差无几。</li><li>Release版: 该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式版本，是最终交付用户使用的一个版本。该版本有时也称为标准版。一般情况下，Release不会以单词形式出现在软件封面上，取而代之的是符号(R)。</li></ul><p><strong>6. 子项目介绍</strong></p><img src="https://gaofee.cc/images/202303171135767.png" alt="sub-projects-info" style="zoom:67%;"><p><strong>7. 常用组件</strong></p><p>下面列举了在Spring Cloud微服务开发中常用的组件，主要包含6部分，也是微服务应具备的能力</p><blockquote><p>服务发现——Netflix Eureka（2.0闭源，Zookeeper、Consul、Nacos逐步替代Eureka）</p></blockquote><blockquote><p>客服端负载均衡——Ribbon</p></blockquote><blockquote><p>断路器——Hystrix</p></blockquote><blockquote><p>服务网关——Gateway</p></blockquote><blockquote><p>分布式配置—— Config</p><p>声明式服务调用——Feign</p></blockquote><p>上面列举了在Spirng Cloud中生态中常用组件，在企业级应用中，使用上述6个Spirng Cloud高级组件，就可以完成微服务的开发和应用</p><h2 id="_1-3-深入理解" tabindex="-1"><a class="header-anchor" href="#_1-3-深入理解" aria-hidden="true">#</a> 1.3 深入理解</h2><p><strong>1.DevOps</strong></p><ul><li><p>DevOps简介</p><p>DevOps（Development和Operations的组合词）是一组过程、方法与系统的统称，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。</p><p>它是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。</p><p>它的出现是由于软件行业日益清晰地认识到：为了按时交付软件产品和服务，开发和运营工作必须紧密合作。</p><p>直观一点的去解释就是DevOps他要求开发、测试、运维进行一体化的合作，进行更小、更频繁、更自动化的应用发布，以及围绕应用架构来构建基础设施的架构。这就要求应用充分的内聚，也方便运维和管理。这个理念与微服务理念不谋而合。</p></li><li><p>DevOps实现</p><p>企业常用DevOps实现： Docker、k8s、Jenkins（CI/CD）</p></li></ul><p><strong>2.微服务测试</strong></p><table><thead><tr><th style="text-align:center;">API测试</th><th>压力测试</th><th style="text-align:center;">分桶测试(AB测试)</th></tr></thead><tbody><tr><td style="text-align:center;">JUnit</td><td>Jmeter</td><td style="text-align:center;">Google 的Optimize</td></tr><tr><td style="text-align:center;">Mockito</td><td></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">swagger2</td><td></td><td style="text-align:center;"></td></tr></tbody></table><p><strong>3. 运维监控</strong></p>',22),m=e("li",null,[e("p",null,"常用运维监控工具Zabbix、Nagios、NetXMS、gangla")],-1),b=e("p",null,"目前常用的运维监控工具就是Nagios",-1),h=e("p",null,[e("strong",null,"Nagios简介")],-1),f={href:"https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151",target:"_blank",rel:"noopener noreferrer"},E={href:"https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E5%99%A8/108294",target:"_blank",rel:"noopener noreferrer"},k=e("p",null,[e("strong",null,"Nagios监控功能")],-1),x=e("p",null,"1、监控网络服务（SMTP、POP3、HTTP、NNTP、PING等）；",-1),S=e("p",null,"2、监控主机资源（处理器负荷、磁盘利用率等）；",-1),_=e("p",null,"3、简单地插件设计使得用户可以方便地扩展自己服务的检测方法；",-1),C=e("p",null,"4、并行服务检查机制；",-1),y={href:"https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82",target:"_blank",rel:"noopener noreferrer"},A={href:"https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA",target:"_blank",rel:"noopener noreferrer"},B=e("p",null,"7、可以定义一些处理程序，使之能够在服务或者主机发生故障时起到预防作用；",-1),R=e("p",null,"8、自动的日志滚动功能；",-1),I={href:"https://baike.baidu.com/item/%E5%86%97%E4%BD%99",target:"_blank",rel:"noopener noreferrer"},N=e("p",null,"10、可选的WEB界面用于查看当前的网络状态、通知和故障历史、日志文件等； [1]",-1),T=e("p",null,"11、可以通过手机查看系统监控信息；",-1),P=e("p",null,"12、可指定自定义的事件处理控制器",-1),w=r(`<h2 id="_1-4-框架对比" tabindex="-1"><a class="header-anchor" href="#_1-4-框架对比" aria-hidden="true">#</a> 1.4 框架对比</h2><p><strong>1. Spring Cloud 与 Dubbo对比</strong></p><ul><li><p>Dubbo简介</p><p>Dubbo是阿里旗下的一个弹性的分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案</p></li></ul><img src="https://gaofee.cc/images/202303171135768.png" alt="dubbo" style="zoom:50%;"><ul><li>Spring Cloud 与 Dubbo对比</li></ul><img src="https://gaofee.cc/images/202303171135769.jpg" alt="dubbo-springcloud" style="zoom:80%;"><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Dubbo 专注 RPC 和服务治理，Spring Cloud 则是一个微服务架构生态
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>2. Spring Cloud 与 k8s对比</strong></p><ul><li><p>K8s简介</p><p>kubernetes，简称K8s，是用8代替8个字符“ubernete”而成的缩写。是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种机制。</p></li><li><p>Spring Cloud 与 k8s对比</p></li></ul><table><thead><tr><th>微服务关注点</th><th>Spring Cloud</th><th>K8s</th></tr></thead><tbody><tr><td>配置管理</td><td>Config</td><td>K8Ss ConfigMap</td></tr><tr><td>服务发现</td><td>Eureka、Consul、Zookeeper、Nacos</td><td>K8s Services</td></tr><tr><td>负载均衡</td><td>Ribbon</td><td>K8s Services</td></tr><tr><td>网关</td><td>Gateway</td><td>K8s Services</td></tr><tr><td>分布式追踪</td><td>Sleuth</td><td>Open tracing</td></tr><tr><td>容错</td><td>Hystrix</td><td>K8s Health Check</td></tr></tbody></table><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Spring Cloud是构建微服务的分布式生态框架，K8s是对运行的容器进行管理和编排，两者在构建微服务层面有着本质的区别，而Spring Cloud和K8s在服务治理上却有着异曲同工之妙
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>3. 其他主流分布式框架</strong></p><table><thead><tr><th>服务治理</th><th>Dubbo</th><th>DubboX</th><th>Montan</th></tr></thead><tbody><tr><td>多语言</td><td>gRpc</td><td>Thrift</td><td></td></tr></tbody></table><p>上面列举了5个比较前沿的分布式框架</p><p>服务治理分类包含三个Dubbo、DubboX、Montan</p><p>多语言分类包含两个gRpc、Thrift</p><h2 id="_1-5-总结" tabindex="-1"><a class="header-anchor" href="#_1-5-总结" aria-hidden="true">#</a> 1.5 总结</h2><p>当前章节主要介绍了架构的演变过程，从传统单体架构、SOA架构最后演变到现在的微服务架构，</p><p>Spring Cloud作为分布式场微服务架构，它是基于Spring boot技术栈构建的，在上面的介绍中，详细的阐述了每个版本的一个对应关系、Spring Cloud项目位置、常用的高级组件以及子项目全部组件</p><p>微服务开发和单体架构的开发在服务数量上是有非常大的差距，所以在上面提到了DevOps的实现，比如基于Docker容器化技术、K8S等等这些比较优秀的开源容器组件；以及微服务运维监控的常用组件、测试常用手段</p><p>Spring Cloud框架可以快速的构建我们的微服务，K8s是对运行的容器进行编排和管理的，他们在构建微服务的层面上有着本质的区别，可是，Spring Cloud和K8s在服务治理上却有异曲同工之妙，比如服务发现、负载均衡、网关、配置管理等,所以对K8s的服务治理做了比较</p><p>由于分布式框架比较常用的是Duubo，所以在上面主要和Dubbo进行了框架比较</p><h1 id="_2-eureka服务治理" tabindex="-1"><a class="header-anchor" href="#_2-eureka服务治理" aria-hidden="true">#</a> 2 Eureka服务治理</h1><h2 id="_2-1-eureka概述" tabindex="-1"><a class="header-anchor" href="#_2-1-eureka概述" aria-hidden="true">#</a> 2.1 Eureka概述</h2><p><strong>1. Eureka简介</strong></p><p>Eureka是Netflix 在线影片公司开源的一个服务注册与发现的组件，和其他Netflix 公司的服务组件（例如负载均衡、熔断器、网关等） 一起，被Spring Cloud 社区整合为Spring Cloud Netflix 模块。和Consul 、Zookeeper 类似， Eureka 是一个用于服务注册和发现的组件， 最开始主要应用于亚马逊公司旗下的云计算服务平台AWS。Eureka 分为Eureka Server 和Eureka Client, Eureka Server 为Eureka 服务注册中心， Eureka Client 为Eureka 客户端。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Eureka包含两个组件：Eureka Server(注册中心)和Eureka Client(服务提供者、服务消费者)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>2. Eureka工作原理</strong></p><img src="https://gaofee.cc/images/202303171135770.png" alt="eureka-architecture" style="zoom:80%;"><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>服务消费的基本过程如下：
首先前要一个服务注册中心Eureka Server ，Eureka Server之间通过复制形式同步信息，服务提供者EurekaClient 向服务注册中心Eureka Server 注册，将自己的信息（比如服务名和服务的IP 地址等）提交给服务注册中心Eureka Server 。同样，服务消费者Eureka Client 也向服务注册中心Eureka Server 注册，同时服务消费者获取一份服务注册列表的信息， 该列表包含了所有向脱务注册中心Eureka Server 注册的服务信息。获取服务注册列表信息之后，服务消费者就知道服务提供者的IP 地址，可以通过HTTP远程调度来消费服务提供者的服务。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3. Eureka2.0闭源</strong></p>`,31),D=e("img",{src:"https://gaofee.cc/images/202303171135771.png",alt:"eureka-discontinued",style:{zoom:"80%"}},null,-1),q={href:"https://github.com/Netflix/eureka/wiki",target:"_blank",rel:"noopener noreferrer"},L=r(`<p>大意是Eureka 2.x的开源分支已关闭，如果要使用，请自己承担风险。1.x版本仍然继续维护。</p><p><strong>当前企业级现状：</strong></p><p>现在企业级应用中已基本摒弃Eureka，因为2.0官方不在维护，后续业务场景中出现问题，凭借自己的力量是很难驾驭，目前，慢慢的通过zookeeper、Consul、Nacos去替代Eureka。</p><p><strong>4. 高可用</strong></p><p>简单的说，服务端当其中一台的服务发生故障时不影响整体服务状况，不能因为一台服务器的问题导致服务停止，高可用的方法有三种：主从方式、双机双工方式、集群工作方式。</p><p>而Zookeeper采用的是主从方式、Eureka则采用的是集群方式，当多台服务器相互注册就形成了高可用，这样当其中的一台停止提供服务时，剩余的则会继续提供服务</p><p><strong>5.Eureka如何实现高可用</strong></p><figure><img src="https://gaofee.cc/images/202303171135772.png" alt="1571275716910" tabindex="0" loading="lazy"><figcaption>1571275716910</figcaption></figure><p>就是通过多个eureka实例进行互相注册，然后修改每个实例的serviceUrl即可。Eureka Server的高可用实际上就是将自己作为服务向其他服务注册中心注册自己，这样就可以形成一组互相注册的服务注册中心，以实现服务清单的互相同步，达到高可用的效果。</p><p><strong>具体实现参照快速入门案例</strong></p><p><strong>6. Eureka注册中心安全认证</strong></p><p>Eureka注册中心的管理界面以及服务注册到服务端时没有任何认证安全机制，如果这个url有公网IP的话，任何热都可以直接访问到，这样显然不安全的，安全性比较差，如果其它服务恶意注册一个同名服务，但是实现不同，可能我们的系统或者我们的微服务就有风险了，所以我们在生产环境中对Eureka注册中心一定要有安全保证机制</p><p>我们可以通过用户认证通过spring-security来开始用户认证</p><p><strong>具体实现参照快速入门案例</strong></p><p><strong>7. 高可用及安全认证工作原理</strong></p><figure><img src="https://gaofee.cc/images/202303171135773.png" alt="1571275932679" tabindex="0" loading="lazy"><figcaption>1571275932679</figcaption></figure><p>从上图可知，我们的服务注册中心Eureka-server1、Eureka-server2两者相互注册，形成了高可用集群，Eureka-server1、Eureka-server2通过复制的形式进行信息的同步，Eureka-server1、Eureka-server2开启了安全认证。Porvider提供者向服务注册中心注册的时候也采取了注册认证，否则是无法将自己注册到服务注册中心；Consumer消费者同时也是提供者，它也需要向注册中心注册自己，同理，也会采取认证的机制。</p><p>这样的话，我们的服务注册中心客户端都有了安全保证机制，在有认证的情况才会将自己成功的注册到Eureka服务端。</p><h2 id="_2-2-eureka核心" tabindex="-1"><a class="header-anchor" href="#_2-2-eureka核心" aria-hidden="true">#</a> 2.2 Eureka核心</h2><p><strong>1.核心概念</strong></p><ul><li><p>Eureka服务端</p><p>Eureka Server提供服务发现的能力，各个微服务启动时，会通过Eureka Client向Eureka Server进行注册自己的信息（例如网络信息），Eureka Server会存储该服务的信息。</p></li><li><p>Eureka客户端</p><p>服务提供者也是服务消费者，也可以统称为客户端，它是一个Java客户端（Eureka Client），用于简化与Eureka Server的交互</p></li><li><p>服务注册（register）</p><p>Eureka Client会通过发送REST请求的方式向Eureka Server注册自己的服务，提供自身的元数据，比如ip地址、端口、运行状况指标的url、主页地址等信息。Eureka Server接收到注册请求后，就会把这些元数据信息存储在一个双层的Map中。</p></li><li><p>服务续约（renew）：</p><p>在服务注册后，Eureka Client会维护一个心跳来持续通知Eureka Server，说明服务一直处于可用状态，防止被剔除。默认每隔30秒<code>eureka.instance.lease-renewal-interval-in-seconds</code>发送一次心跳来进行服务续约。</p></li></ul><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token comment"># 租约续约间隔时间，默认30秒</span>
<span class="token key atrule">eureka.instance.lease-renewal-interval-in-seconds</span><span class="token punctuation">:</span> <span class="token number">30</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>获取服务列表（Fetch Registries）：</li></ul><p>服务消费者（Eureka Client）在启动的时候，会发送一个REST请求给Eureka Server，获取上面注册的服务清单，并且缓存在Eureka Client本地，默认缓存30秒(eureka.client. registry-fetch-interval-seconds)。同时，为了性能虑，Eureka Server也会维护一份只读的服务清单缓存，该缓存每隔30秒更新一次。</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token comment"># 每隔多久获取服务中心列表，</span>
<span class="token key atrule">eureka.client.registry-fetch-interval-seconds</span><span class="token punctuation">:</span> <span class="token number">30</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>服务调用：</p><p>服务消费者在获取到服务清单后，就可以根据清单中的服务列表信息，查找到其他服务的地址，从而进行远程调用。</p></li><li><p>服务下线（cancel）：</p><p>当Eureka Client需要关闭或重启时，就不希望在这个时间段内再有请求进来，所以，就需要提前先发送REST请求给Eureka Server，告诉Eureka Server自己要下线了，Eureka Server在收到请求后，就会把该服务状态置为下线（DOWN），并把该下线事件传播出去。</p></li><li><p>数据同步（Replicate）</p><p>处于不同节点的eureka通过Replicate进行数据同步</p></li><li><p>失效剔除（evict）：</p><p>服务实例可能会因为网络故障等原因，导致不能提供服务，而此时该实例也没有发送请求给Eureka Server来进行服务下线。所以，还需要有服务剔除的机制。Eureka Server在启动的时候会创建一个定时任务，每隔一段时间（默认60秒），从当前服务清单中把超时没有续约（默认90秒<code>eureka.instance.lease-expiration-duration-in-seconds</code>）的服务剔除。</p></li></ul><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token comment"># 租约到期，服务时效时间，默认值90秒</span>
<span class="token key atrule">eureka.instance.lease-expiration-duration-in-seconds</span><span class="token punctuation">:</span> <span class="token number">90</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>自我保护：</p><p>既然Eureka Server会定时剔除超时没有续约的服务，那就有可能出现一种场景，网络一段时间内发生了异常，所有的服务都没能够进行续约，Eureka Server就把所有的服务都剔除了，这样显然不太合理。所以，就有了自我保护机制，当短时间内，统计续约失败的比例，如果达到一定阈值，则会触发自我保护的机制，在该机制下，Eureka Server不会剔除任何的微服务，等到正常后，再退出自我保护机制。自我保护开关(eureka.server.enable-self-preservation: false)</p></li></ul><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token comment">#向Eureka服务中心集群注册服务</span>
<span class="token key atrule">eureka.server.enable-self-preservation</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 关闭自我保护模式（默认值是打开）</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2. Eureka区域与可用区</strong></p><p>Eureka的官方文档对regin、zone没有更多提及，region和zone（或者Availability Zone）均是AWS的概念。在非AWS环境下，我们可以简单地将region理解为Eureka集群，zone理解成机房。</p><p>Spring Cloud中默认的region是<code>us-east-1</code></p><p><strong>3. Eureka元数据</strong></p><p>Eureka的元数据有两种：</p><ul><li>标准元数据和自定义元数据标准元数据：主机名、IP地址、端口号、状态页和健康检查等信息，这些信息都会被发布在服务注册表中，用于服务之间的调用。</li><li>自定义元数据：可以使用eureka.instance.metadata-map配置，这些元数据可以在远程客户端中访问，但是一般不改变客户端行为，除非客户端知道该元数据的含义</li></ul><p><strong>4. Eureka多网卡IP选择</strong></p><p>在Linux主机部署Eureka高可用时，注册到服务中心的服务IP是随机的，由于客户端的网卡是多个，随机（有可能是虚拟机）的IP并不是自己想要的,在进行服务调用的时候可能会出现网络不通</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>spring:
  cloud:
    inetutils:
      # 忽略指定网卡，支持正则表达式（这里使用正则表达式忽略所有虚拟机网卡）
      ignoredInterfaces: [&#39;VMware.*&#39;]
和
 instance:
    prefer-ip-address: true
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-3-eureka快速入门-单点" tabindex="-1"><a class="header-anchor" href="#_2-3-eureka快速入门-单点" aria-hidden="true">#</a> 2.3 Eureka快速入门（单点）</h2><p><strong>本章节场景：</strong></p><p>我们将建立两个Module，父Module是itheima-chapter-02，里面没有任何代码，它用来管理我们的聚合工程。</p><p>我们建立一个eureka-server-register服务端，然后建立一个eureka-client-discover客户单，然后将客户单端注册到eureka-server-register服务端上面。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>        &lt;module&gt;eureka-client-discover&lt;/module&gt;  #单点
        &lt;module&gt;eureka-server-register&lt;/module&gt;  #单点
        &lt;module&gt;eureka-server-ha-security&lt;/module&gt;#集群+安全认证
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>章节代码：itheima-chapter-02,工程结构如下图：</p><figure><img src="https://gaofee.cc/images/202303171135774.png" alt="1569324817175" tabindex="0" loading="lazy"><figcaption>1569324817175</figcaption></figure><p><strong>2.4.1 搭建服务端</strong></p><p><strong>1) 创建eureka-server-register模块</strong></p><p>搭建Eureka服务端用于服务注册发现，对应的父工程为itheima-chapter-02,用于管理下面的Module项目</p><p><strong>2) 父pom.xml引入起步依赖</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>	&lt;properties&gt;
		&lt;spring-cloud.version&gt;Greenwich.RELEASE&lt;/spring-cloud.version&gt;
	&lt;/properties&gt;
	&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
			&lt;version&gt;\${spring-cloud.version}&lt;/version&gt;
			&lt;type&gt;pom&lt;/type&gt;
			&lt;scope&gt;import&lt;/scope&gt;
		&lt;/dependency&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3) eureka-server-register引入起步依赖</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring‐cloud‐starter‐netflix‐eureka‐server&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>4) 修改application.yml文件</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>server:
  port: 8761

eureka:
  instance:
    hostname: localhost
  client:
    registerWithEureka: false #是否将自己注册到Eureka服务中，本身就是所有无需注册
    fetchRegistry: false #是否从Eureka中获取注册信息
    serviceUrl: #Eureka客户端与Eureka服务端进行交互的地址
      defaultZone: http://\${eureka.instance.hostname}:\${server.port}/eureka/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>5) 运行服务注册中心</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@EnableEurekaServer
@SpringBootApplication
public class EurekaServerApplication {

	public static void main(String[] args) {
		SpringApplication.run(EurekaServerApplication.class, args);
	}

}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>6) 访问</strong></p>`,57),O={href:"http://localhost:8761/",target:"_blank",rel:"noopener noreferrer"},M=r(`<figure><img src="https://gaofee.cc/images/202303171135775.png" alt="eureka-8761" tabindex="0" loading="lazy"><figcaption>eureka-8761</figcaption></figure><p><strong>2.4.2 搭建客户端</strong></p><p><strong>1) 创建eureka-client-discover模块</strong></p><p>将所有的微服务都注册到Eureka中，这样所有的微服务之间都可以互相调用了，对应的父工程为itheima-chapter-02,用于管理下面的Module项目</p><p><strong>2) eureka-client-discover引入起步依赖</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3) 修改application.yml文件</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>4) 运行客户端</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@SpringBootApplication
@EnableEurekaClient
public class EurekaClientApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaClientApplication.class, args);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>5) 查看注册实例</strong></p>`,11),z={href:"http://localhost:8761/",target:"_blank",rel:"noopener noreferrer"},F=r(`<figure><img src="https://gaofee.cc/images/202303171135776.png" alt="eureka-client-8761" tabindex="0" loading="lazy"><figcaption>eureka-client-8761</figcaption></figure><p><strong>2.4.3 灰度发布(优雅停服)</strong></p><p>此处使用的是配置端点的方式</p><p><strong>1) 客户端增加监控起步依赖</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
		&lt;/dependency&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2) 修改客户端application.yml文件</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>management:
  endpoints:
    web:
      exposure:
        include: &quot;*&quot;
  endpoint:
    health:
      show-details: ALWAYS
    shutdown:
      enabled: true # 必须将此属性设置为true 才能执行 curl -X POST http://localhost:9001/actuator/shutdown 命令
  server:
    port: 9001 # 指定Actuator对外暴露的REST API接口端口为9001
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>执行优雅下线</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>C:\\Users\\Administrator&gt;curl -X &quot;POST&quot;   http://localhost:9001/actuator/shutdown
提示：{&quot;message&quot;:&quot;Shutting down, bye...&quot;}，即为成功停服
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-4-eureka快速入门-集群" tabindex="-1"><a class="header-anchor" href="#_2-4-eureka快速入门-集群" aria-hidden="true">#</a> 2.4 Eureka快速入门（集群）</h2><p><strong>本章节场景：</strong></p><p>我们将建立三个Module，父Module是itheima-chapter-02，里面没有任何代码，它用来管理我们的聚合工程。</p><p>此处有一个eureka-server-ha-security，它也和上面同理，里面没有任何代码，用来管理我们的聚合工程。</p><p>我们建立一个eureka-server-register-ha-security-1和eureka-server-register-ha-security-2服务端，他们之间相互注册，形成高可用集群（企业生产环境集群数量比这要多），并且这两个服务端都开启安全认证，然后建立一个eureka-client-discover-ha-security客户端，将客户端注册（携带安全认证进行注册）到eureka-server-register-ha-security-1服务端上面，查看eureka-server-register-ha-security-1和eureka-server-register-ha-security-2是否进行信息（client是否全部注册到了服务端上面）同步，然后停掉一个Eureka服务注册中心，查看服务是否能正常访问</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>        &lt;module&gt;eureka-client-discover&lt;/module&gt;  #单点
        &lt;module&gt;eureka-server-register&lt;/module&gt;  #单点
        &lt;module&gt;eureka-server-ha-security&lt;/module&gt;#集群+安全认证
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>章节代码：itheima-chapter-02,工程结构如下图：</p><figure><img src="https://gaofee.cc/images/202303171135777.png" alt="1570584269881" tabindex="0" loading="lazy"><figcaption>1570584269881</figcaption></figure><p><strong>2.4.1 集群节点Node1</strong></p><p><strong>1) 创建eureka-server-register-ha-security-1模块</strong></p><p>搭建Eureka服务端eureka-server-register-ha-security-1用于集群服务注册发现</p><p>它对应的父项目是eureka-server-ha-security</p><p><strong>2) 父pom.xml引入起步依赖</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>        &lt;module&gt;eureka-client-discover-ha-security&lt;/module&gt;
        &lt;module&gt;eureka-server-register-ha-security-1&lt;/module&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3) eureka-server-register-ha-security-1引入起步依赖</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring‐cloud‐starter‐netflix‐eureka‐server&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>4) 修改application.yml文件</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>spring:
  application:
    name: eureka-server

server:
  port: 7777

eureka:
  server:
    enable-self-preservation: false #关闭自我保护机制
  instance:
    prefer-ip-address: true
    hostname: eureka1
  # 禁止向自己注册 必须将eureka.client.register-with-eureka和eureka.client.fetch-registry 设置为false
  client:
    register-with-eureka: false #是否将自己注册到Eureka服务中，本身就是所有无需注册
    fetch-registry: false #是否从Eureka中获取注册信息
    service-url: #Eureka客户端与Eureka服务端进行交互的地址
      defaultZone: http://eureka2:8888/eureka/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,27),H=e("strong",null,"和单点唯一不同地方",-1),U={href:"http://eureka2:8888/eureka/",target:"_blank",rel:"noopener noreferrer"},W=r(`<p>eureka-server-register-ha-security-1的defaultZone为eureka-server-register-ha-security-2注册地址</p><p>eureka-server-register-ha-security-2的defaultZone为eureka-server-register-ha-security-1注册地址</p><p>采用了Eureka集群相互注册的理念搭建Eureka集群</p><p><strong>5) 运行服务注册中心</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@EnableEurekaServer
@SpringBootApplication
public class EurekaServerApplication {

	public static void main(String[] args) {
		SpringApplication.run(EurekaServerApplication.class, args);
	}

}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2.4.2 集群节点Node2</strong></p><p><strong>1) 创建eureka-server-register-ha-security-2模块</strong></p><p>搭建Eureka服务端eureka-server-register-ha-security-2用于集群服务注册发现</p><p>它对应的父项目是eureka-server-ha-security</p><p><strong>2) 父pom.xml引入起步依赖</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>        &lt;module&gt;eureka-client-discover-ha-security&lt;/module&gt;
        &lt;module&gt;eureka-server-register-ha-security-2&lt;/module&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3) eureka-server-register-ha-security-2引入起步依赖</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring‐cloud‐starter‐netflix‐eureka‐server&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>4) 修改application.yml文件</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>spring:
  application:
    name: eureka-server
server:
  port: 8888
eureka:
  server:
    enable-self-preservation: false #关闭自我保护机制
  instance:
    prefer-ip-address: true
    hostname: eureka2
  # 禁止向自己注册 必须将eureka.client.register-with-eureka和eureka.client.fetch-registry 设置为false
  client:
    register-with-eureka: false #是否将自己注册到Eureka服务中，本身就是所有无需注册
    fetch-registry: false #是否从Eureka中获取注册信息
    service-url: #Eureka客户端与Eureka服务端进行交互的地址
      defaultZone: http://eureka1:7777/eureka/

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,15),j=e("strong",null,"和单点唯一不同地方",-1),G={href:"http://eureka1:8888/eureka/",target:"_blank",rel:"noopener noreferrer"},K=r(`<p>eureka-server-register-ha-security-1的defaultZone为eureka-server-register-ha-security-2注册地址</p><p>eureka-server-register-ha-security-2的defaultZone为eureka-server-register-ha-security-1注册地址</p><p>采用了Eureka集群相互注册的理念搭建Eureka集群</p><p><strong>5) 运行服务注册中心</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@EnableEurekaServer
@SpringBootApplication
public class EurekaServerApplication {

	public static void main(String[] args) {
		SpringApplication.run(EurekaServerApplication.class, args);
	}

}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2.4.3 配置本机Hosts</strong></p><p>由于当前案例是在一台笔记本上进行的，我们需要配置下Hosts文件配置域名解析，方便我们的Eureka Client注册</p><p>具体步骤是：打开磁盘路径，如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>C:\\Windows\\System32\\drivers\\etc
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>加入下面红框内的映射信息</p><figure><img src="https://gaofee.cc/images/202303171135778.png" alt="1570584300528" tabindex="0" loading="lazy"><figcaption>1570584300528</figcaption></figure><p><strong>2.4.4 搭建客户端</strong></p><p><strong>1) 创建eureka-client-discover-ha-security模块</strong></p><p>将eureka-client-discover-ha-security注册到集群中某一个节点</p><p><strong>2) eureka-client-discover-ha-security引入起步依赖</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3) 修改application.yml文件</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>spring:
  cloud:
  application:
    name: eureka-client
server:
  port: 9999

eureka:
  client:
    service-url:
      defaultZone: http://eureka1:7777/eureka/,http://eureka2:8888/eureka/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,18),V={href:"http://eureka1:7777/eureka/%EF%BC%8C%E8%BF%99%E4%B8%AAeureka1%E5%B0%B1%E6%98%AF%E6%88%91%E4%BB%AC%E5%9C%A8Hosts%E6%96%87%E4%BB%B6%E4%B8%AD%E9%85%8D%E7%BD%AE%E7%9A%84%E6%98%A0%E5%B0%84",target:"_blank",rel:"noopener noreferrer"},Z=r(`<p><strong>4) 客户端入口</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@SpringBootApplication
@EnableEurekaClient
public class EurekaClientApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaClientApplication.class, args);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>4) 启动</strong></p><p>分别启动eureka-server-register-ha-security-1、eureka-server-register-ha-security-2、eureka-client-discover-ha-security，也可以不按照启动，如果先启动客户端，可能会报错，但是，等启动玩服务端就不报错了</p><p><strong>5) 查看注册实例</strong></p>`,5),X={href:"http://localhost:8888/%E5%92%8Chttp://localhost:7777/%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A",target:"_blank",rel:"noopener noreferrer"},$=r(`<figure><img src="https://gaofee.cc/images/202303171135779.png" alt="1570584340766" tabindex="0" loading="lazy"><figcaption>1570584340766</figcaption></figure><p>​ （eureka1端口为7777的节点）</p><figure><img src="https://gaofee.cc/images/202303171135780.png" alt="1570584357413" tabindex="0" loading="lazy"><figcaption>1570584357413</figcaption></figure><pre><code>																		 （eureka2端口为8888的节点）
</code></pre><p>**红框属性解释：**详见下面</p><p><strong>总结：</strong></p><p>上面是我们集群中的节点，对应节点为 eureka2端口为8888的节点、eureka1端口为7777的节点</p><p>1、在端口为7777的节点中，它的副本replica是eureka2，也就是对应了端口8888的节点</p><p>2、在端口为8888的节点中，它的副本replica是eureka1，也就是对应了端口7777的节点</p><p>说明集群中的节点完成了相互注册，并形成了高可用集群</p><p>3、在端口为7777的节点中，Instances currently registered with Eureka有<strong>EUREKA-CLIENT</strong>的实例信息</p><p>4、在端口为8888的节点中，Instances currently registered with Eureka有<strong>EUREKA-CLIENT</strong>的实例信息</p><p>说明我们的客户端虽然只注册到了eureka1对应的端口7777上面，最后我们发现eureka2对应的端口88888上面</p><p>也有<strong>EUREKA-CLIENT</strong>的实例信息，说明了集群节点的信息同步</p>`,14),J={href:"http://localhost:9999/itheima?name=itheima",target:"_blank",rel:"noopener noreferrer"},Y=r(`<p>1、正常情况下，访问api</p><figure><img src="https://gaofee.cc/images/202303171135781.png" alt="1570584384322" tabindex="0" loading="lazy"><figcaption>1570584384322</figcaption></figure><p>2、停掉eureka1，eureka2正常，如下图：</p><figure><img src="https://gaofee.cc/images/202303171135782.png" alt="1570584401689" tabindex="0" loading="lazy"><figcaption>1570584401689</figcaption></figure><figure><img src="https://gaofee.cc/images/202303171135783.png" alt="1570584419072" tabindex="0" loading="lazy"><figcaption>1570584419072</figcaption></figure><p>3、服务可以正常访问，如下</p><figure><img src="https://gaofee.cc/images/202303171135784.png" alt="1571275777575" tabindex="0" loading="lazy"><figcaption>1571275777575</figcaption></figure><h2 id="_2-5-eureka-web" tabindex="-1"><a class="header-anchor" href="#_2-5-eureka-web" aria-hidden="true">#</a> 2.5 Eureka Web</h2><p>下图将介绍下Eureka Web页面参数作用</p><figure><img src="https://gaofee.cc/images/202303171135785.png" alt="1570584433399" tabindex="0" loading="lazy"><figcaption>1570584433399</figcaption></figure><p><strong>1、System Status</strong> Environment: 环境，默认为test，该参数在实际使用过程中，可以不用更改 Data center： 数据中心，使用的是默认的是 “MyOwn” Current time：当前的系统时间 Uptime：已经运行了多少时间 Lease expiration enabled：是否启用租约过期 ，自我保护机制关闭时，该值默认是true， 自我保护机制开启之后为false。 Renews threshold： 每分钟最少续约数，Eureka Server 期望每分钟收到客户端实例续约的总数。 Renews (last min)： 最后一分钟的续约数量（不含当前，1分钟更新一次），Eureka Server 最后 1 分钟收到客户端实例续约的总数。</p><p><strong>2、红字提醒</strong> 系统在三种情况下会出现红色加粗的字体提示：</p><p>a.在配置上，自我保护机制关闭 RENEWALS ARE LESSER THAN THE THRESHOLD. THE SELF PRESERVATION MODE IS TURNED OFF.THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OF NETWORK/OTHER PROBLEMS.</p><p>b.自我保护机制开启了 EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&#39;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</p><p>c.在配置上，自我保护机制关闭了，但是一分钟内的续约数没有达到85% ， 可能发生了网络分区，会有如下提示 THE SELF PRESERVATION MODE IS TURNED OFF.THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OF NETWORK/OTHER PROBLEMS.</p><p><strong>3、DS Replicas</strong></p><p>replicas：副本，由于Eureka集群中的Eureka实例之间相互同步注册信息，Eureka实例称其他Eureka实例为自己的replicas，这个下面的信息是这个Eureka Server相邻节点，互为一个集群</p><p><strong>4、Instances currently registered with Eureka</strong></p><p>册到这个服务上的实例信息</p><p><strong>5、General Info</strong></p><p>total-avail-memory : 总共可用的内存 environment : 环境名称，默认test num-of-cpus : CPU的个数 current-memory-usage : 当前已经使用内存的百分比 server-uptime : 服务启动时间 registered-replicas : 相邻集群复制节点 unavailable-replicas ：不可用的集群复制节点，如何确定不可用？ 主要是server1 向 server2和server3发送接口查询自身的注册信息， 如果查询不到，则默认为不可用，也就是说如果Eureka Server自身不作为客户端注册到上面去，则相邻节点都会显示为不可用。</p><p>available-replicas ：可用的相邻集群复制节点</p><p><strong>6、Instance Info</strong></p><p>ipAddr：eureka服务端IP status：eureka服务端状态</p><h2 id="_2-6-安全验证" tabindex="-1"><a class="header-anchor" href="#_2-6-安全验证" aria-hidden="true">#</a> 2.6 安全验证</h2><p><strong>2.6.1 修改集群节点Node1</strong></p><p><strong>1) 修改eureka-server-register-ha-security-1模块</strong></p><p>修改上面的Module模块eureka-server-register-ha-security-1，为我们的Eureka Server开启安全认证</p><p><strong>2) 引入安全验证起步依赖</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
        &lt;/dependency&gt; 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3) 修改application.yml文件</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>spring:
  security:
    basic:
      enabled: true  #开启验证
    user:
      name: itheima  #验证用户名
      password: 123456 #验证密码
      
eureka:
  client:
    service-url: #Eureka客户端与Eureka服务端进行交互的地址
      defaultZone: http://itheima:123456@eureka2:8888/eureka/ ,http://itheima:123456@eureka1:7777/eureka/ #注册中心相互之间也需要认证，设置账号密码

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>5) 关闭csrf令牌</strong></p><p>csrf会对URL请求进行token验证，如果请求中没有token,浏览器会任务是非法网页的请求，然后就会拒绝</p><p>所以要关闭csrf；增加了类WebSecurityConfig继承WebSecurityConfigurerAdapter，关闭csrf令牌</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().ignoringAntMatchers(&quot;/eureka/**&quot;);
        super.configure(http);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://gaofee.cc/images/202303171135786.png" alt="1571275818898" tabindex="0" loading="lazy"><figcaption>1571275818898</figcaption></figure><p>保护Eureka服务器，为什么要关闭csrf，以上是官方的解释，翻译出来大意是：</p><p>12.7保护Eureka服务器 您只需通过spring-boot-starter-security将Spring Security添加到服务器的类路径中，即可保护Eureka服务器。 默认情况下，当Spring Security在类路径上时，它将要求将有效的CSRF令牌与每个请求一起发送到应用程序。 Eureka客户通常不会拥有有效的跨站点请求伪造（CSRF）令牌，因此您需要为/ eureka / **端点禁用此要求</p><p>如果不关闭csrf，客户端是否无法注册到Eureka Server上的</p><p><strong>2.6.2 修改集群节点Node2</strong></p><p><strong>1) 修改eureka-server-register-ha-security-2模块</strong></p><p>修改上面的Module模块eureka-server-register-ha-security-2，为我们的Eureka Server开启安全认证</p><p><strong>2) 引入安全验证起步依赖</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
        &lt;/dependency&gt; 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3) 修改application.yml文件</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>spring:
  security:
    basic:
      enabled: true  #开启验证
    user:
      name: itheima  #验证用户名
      password: 123456 #验证密码
      
eureka:
  client:
    service-url: #Eureka客户端与Eureka服务端进行交互的地址
      defaultZone: http://itheima:123456@eureka1:8888/eureka/  #注册中心相互之间也需要认证，设置账号密码

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>5) 关闭csrf令牌</strong></p><p>增加了类WebSecurityConfig继承WebSecurityConfigurerAdapter，关闭csrf令牌</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().ignoringAntMatchers(&quot;/eureka/**&quot;);
        super.configure(http);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://gaofee.cc/images/202303171135787.png" alt="1571275865984" tabindex="0" loading="lazy"><figcaption>1571275865984</figcaption></figure><p>保护Eureka服务器，为什么要关闭csrf，以上是官方的解释，翻译出来大意是：</p><p>12.7保护Eureka服务器 您只需通过spring-boot-starter-security将Spring Security添加到服务器的类路径中，即可保护Eureka服务器。 默认情况下，当Spring Security在类路径上时，它将要求将有效的CSRF令牌与每个请求一起发送到应用程序。 Eureka客户通常不会拥有有效的跨站点请求伪造（CSRF）令牌，因此您需要为/ eureka / **端点禁用此要求</p><p><strong>如果不关闭csrf，客户端是否无法注册到Eureka Server上的</strong></p><p><strong>2.6.3 启动服务端</strong></p>`,55),Q={href:"http://localhost:8888/%E6%88%96%E8%80%85http://localhost:7777%E9%83%BD%E4%BC%9A%E8%A6%81%E6%B1%82%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%EF%BC%8C%E8%BF%99%E6%A0%B7%E7%9A%84%E8%AF%9D%EF%BC%8C%E6%88%91%E4%BB%AC%E7%9A%84Eureka%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B0%B1%E5%8F%97%E5%88%B0%E4%BA%86%E4%BF%9D%E6%8A%A4",target:"_blank",rel:"noopener noreferrer"},ee=r(`<figure><img src="https://gaofee.cc/images/202303171135788.png" alt="1570584456738" tabindex="0" loading="lazy"><figcaption>1570584456738</figcaption></figure><p><strong>2.4.3 修改客户端</strong></p><p><strong>1) 修改eureka-client-discover-ha-security模块</strong></p><p>​ 在eureka-client-discover-ha-security代码基础上增加安全认证注册</p><p><strong>2) 修改application.yml文件</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>eureka:
  client:
    service-url:
      defaultZone: http://itheima:123456@eureka1:7777/eureka/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于Eureka Server启用了安全认证，所以，客户端在注册到服务端时需要提供用户名密码的验证</p><p>这样的话就可以正常的注册到Eureka Server中，如下图</p><figure><img src="https://gaofee.cc/images/202303171135789.png" alt="1570584469505" tabindex="0" loading="lazy"><figcaption>1570584469505</figcaption></figure><h2 id="_2-7-总结" tabindex="-1"><a class="header-anchor" href="#_2-7-总结" aria-hidden="true">#</a> 2.7 总结</h2><p>本章节主要介绍了Eureka单点、集群、安全验证</p><p>微服务（提供者or消费者）统一注册到服务注册中心Eureka服务端，Eureka提供了服务注册和发现的功能，方便我们在分布式场景中进行服务的调用，而不是采用硬编码（代码指远程调用服务的ip、port信息）的方式进行服务调用，通过相互注册搭建高可用集群，在Eureka其中一个节点宕掉时，还能继续为我们提供服务</p><p>我们在注册微服务或者查看微服务的时候，可以通过输入用户名、密码进行查看，Eureka安全为我们的微服务提供了安全保障。</p><h1 id="_3-consul服务治理、配置管理" tabindex="-1"><a class="header-anchor" href="#_3-consul服务治理、配置管理" aria-hidden="true">#</a> 3 Consul服务治理、配置管理</h1><h2 id="_3-1-consul概述" tabindex="-1"><a class="header-anchor" href="#_3-1-consul概述" aria-hidden="true">#</a> 3.1 Consul概述</h2><p><strong>1. Consul简介</strong></p><p>Consul是由HashiCorp基于Go语言开发的支持多数据中心分布式高可用的服务发布和注册服务软件，用于实现分布式系统的服务发现与配置。与其他分布式服务注册与发现的方案，Consul的方案更“一站式”，内置了服务注册与发现框 架、具有以下性质：</p><blockquote><p>分布一致性协议实现、 健康检查、 Key/Value存储、 多数据中心方案， 不再需要依赖其他工具（比如ZooKeeper等）。</p></blockquote><p>使用起来也较 为简单。具有天然可移植性(支持Linux、windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署，与Docker等轻量级容器可无缝配合 。 基于 Mozilla Public License 2.0 的协议进行开源. Consul 支持健康检查,并允许 HTTP 和 DNS 协议调用 API 存储键值对. 一致性协议采用 Raft 算法,用来保证服务的高可用. 使用 GOSSIP 协议管理成员和广播消息, 并且支持 ACL 访问控制。</p><p><strong>2. Consul解决了哪些问题</strong></p><p>服务发现：Consul客户能够注册一个服务，比如api或mysql，其他客户可以在Consul上查询一个指定服务的提供者。Consul提供DNS和HTTP的服务发现接口。</p><p>健康检查：Consul可以灵活的使用脚本等来检测注册在其上的服务是否可用，不健康的服务Consul也能够灵活处理，比如提供服务的主机内存使用超过90%，我们可以配置让Consul不要把这样的服务提供给服务调用者。</p><p>key/value存储：这个功能和etcd有些类似，可以通过HTTP API方便地使用。</p><p>多数据中心支持：Consul支持开箱即用的多数据中心支持，这意味着用户不用建立额外的抽象层让业务扩展到各个区域。</p><p><strong>3. Consul工作原理</strong></p><img src="https://gaofee.cc/images/202303171135790.png" alt="consul-architecture" style="zoom:67%;"><p>1、当 Producer 启动的时候，会向 Consul 发送一个 post 请求，告诉 Consul 自己的 IP 和 Port 2、Consul 接收到 Producer 的注册后，每隔10s（默认）会向 Producer 发送一个健康检查的请求，检验Producer是否健康 3、当 Consumer 发送 GET 方式请求 /api/address 到 Producer 时，会先从 Consul 中拿到一个存储服务 IP 和 Port 的临时表，从表中拿到 Producer 的 IP 和 Port 后再发送 GET 方式请求 /api/address 4、该临时表每隔10s会更新，只包含有通过了健康检查的 Producer</p><p><strong>4 Consul与Eureka比较</strong></p><p>1）什么是CAP定理</p><p>CAP原则又称CAP定理，分布式架构中重要理论,指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，<strong>不可能三者兼顾</strong></p><ul><li>一致性(Consistency) (所有节点在同一时间具有相同的数据)</li><li>可用性(Availability) (保证每个请求不管成功或者失败都有响应)</li><li>分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)</li></ul><p>2）Consul与Eureka比较</p><p>​ 最大的区别是Eureka保证AP, Consul为CP</p><p>​ Consul强一致性(C)带来的是：</p><p>​ 服务注册相比Eureka会稍慢一些。因为Consul的raft协议要求必须过半数的节点都写入成功才认为注册成功 ​ Leader挂掉时，重新选举期间整个consul不可用。保证了强一致性但牺牲了可用性。 ​ Eureka保证高可用(A)和最终一致性：</p><p>​ 服务注册相对要快，因为不需要等注册信息replicate到其他节点，也不保证注册信息是否replicate成功 ​ 当数据出现不一致时，虽然A, B上的注册信息不完全相同，但每个Eureka节点依然能够正常对外提供服务，这 会出现查询服务信息时如果请求A查不到，但请求B就能查到。如此保证了可用性但牺牲了一致性。 ​ 其他方面，eureka就是个servlet程序，跑在servlet容器中; Consul则是go编写而成</p><h2 id="_3-2-consul深入理解" tabindex="-1"><a class="header-anchor" href="#_3-2-consul深入理解" aria-hidden="true">#</a> 3.2 Consul深入理解</h2><p><strong>1. Consul核心模块</strong></p><p>Consul服务治理功能 spring-cloud-consul-discovery</p><p>Consul配置功能 spring-cloud-consul-config</p><p>Consul基础配置和健康检查模块 spring-cloud-consul-core</p><p>Consul事件功能 spring-cloud-consul-binder</p><p><strong>2. Consul服务注册</strong></p><p>向 Consul 发送一个 post 请求，告诉 Consul 自己的 IP 和 Port</p><p><strong>3. Consul服务发现</strong></p><p>Consul通过HTTP API和DNS提供服务发现服务</p><p><strong>4.开发模式</strong></p><p>执行consul agent -dev，启动开发模式，这个模式会快速启动一个单节点的Consul。注意，这个模式不能数据持久化,例如key/value的保存，因此，不能用于生产环境。</p><p><strong>5. Consul常用命令</strong></p><table><thead><tr><th style="text-align:left;">命令</th><th style="text-align:left;">解释</th><th style="text-align:left;">示例</th></tr></thead><tbody><tr><td style="text-align:left;">agent</td><td style="text-align:left;">运行一个consul agent</td><td style="text-align:left;">consul agent -dev</td></tr><tr><td style="text-align:left;">join</td><td style="text-align:left;">将agent加入到consul集群</td><td style="text-align:left;">consul join IP</td></tr><tr><td style="text-align:left;">members</td><td style="text-align:left;">列出consul cluster集群中的members</td><td style="text-align:left;">consul members</td></tr><tr><td style="text-align:left;">leave</td><td style="text-align:left;">将节点移除所在集群</td><td style="text-align:left;">consul leave</td></tr></tbody></table><p>输入<code>consul agent --help</code> ，可以看到<code>consul agent</code> 的选项,如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>  -advertise=addr          Sets the advertise address to use
  -advertise-wan=addr      Sets address to advertise on wan instead of advertise addr
  -atlas=org/name          Sets the Atlas infrastructure name, enables SCADA.
  -atlas-join              Enables auto-joining the Atlas cluster
  -atlas-token=token       Provides the Atlas API token
  -atlas-endpoint=1.2.3.4  The address of the endpoint for Atlas integration.
  -bootstrap               Sets server to bootstrap mode
  -bind=0.0.0.0            Sets the bind address for cluster communication
  -http-port=8500          Sets the HTTP API port to listen on
  -bootstrap-expect=0      Sets server to expect bootstrap mode.
  -client=127.0.0.1        Sets the address to bind for client access.
                           This includes RPC, DNS, HTTP and HTTPS (if configured)
  -config-file=foo         Path to a JSON file to read configuration from.
                           This can be specified multiple times.
  -config-dir=foo          Path to a directory to read configuration files
                           from. This will read every file ending in &quot;.json&quot;
                           as configuration in this directory in alphabetical
                           order. This can be specified multiple times.
  -data-dir=path           Path to a data directory to store agent state
  -dev                     Starts the agent in development mode.
  -recursor=1.2.3.4        Address of an upstream DNS server.
                           Can be specified multiple times.
  -dc=east-aws             Datacenter of the agent (deprecated: use &#39;datacenter&#39; instead).
  -datacenter=east-aws     Datacenter of the agent.
  -encrypt=key             Provides the gossip encryption key
  -join=1.2.3.4            Address of an agent to join at start time.
                           Can be specified multiple times.
  -join-wan=1.2.3.4        Address of an agent to join -wan at start time.
                           Can be specified multiple times.
  -retry-join=1.2.3.4      Address of an agent to join at start time with
                           retries enabled. Can be specified multiple times.
  -retry-interval=30s      Time to wait between join attempts.
  -retry-max=0             Maximum number of join attempts. Defaults to 0, which
                           will retry indefinitely.
  -retry-join-wan=1.2.3.4  Address of an agent to join -wan at start time with
                           retries enabled. Can be specified multiple times.
  -retry-interval-wan=30s  Time to wait between join -wan attempts.
  -retry-max-wan=0         Maximum number of join -wan attempts. Defaults to 0, which
                           will retry indefinitely.
  -log-level=info          Log level of the agent.
  -node=hostname           Name of this node. Must be unique in the cluster
  -protocol=N              Sets the protocol version. Defaults to latest.
  -rejoin                  Ignores a previous leave and attempts to rejoin the cluster.
  -server                  Switches agent to server mode.
  -syslog                  Enables logging to syslog
  -ui                      Enables the built-in static web UI server
  -ui-dir=path             Path to directory containing the Web UI resources
  -pid-file=path           Path to file to store agent PID

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>consul agent</code> 命令的常用选项，如下：</p><ul><li>-data-dir <ul><li>作用：指定agent储存状态的数据目录</li><li>这是所有agent都必须的</li><li>对于server尤其重要，因为他们必须持久化集群的状态</li></ul></li><li>-config-dir <ul><li>作用：指定service的配置文件和检查定义所在的位置</li><li>通常会指定为”某一个路径/consul.d”（通常情况下，.d表示一系列配置文件存放的目录）</li></ul></li><li>-config-file <ul><li>作用：指定一个要装载的配置文件</li><li>该选项可以配置多次，进而配置多个配置文件（后边的会合并前边的，相同的值覆盖）</li></ul></li><li>-dev <ul><li>作用：创建一个开发环境下的server节点</li><li>该参数配置下，不会有任何持久化操作，即不会有任何数据写入到磁盘</li><li>这种模式不能用于生产环境（因为第二条）</li></ul></li><li>-bootstrap-expect <ul><li>作用：该命令通知consul server我们现在准备加入的server节点个数，该参数是为了延迟日志复制的启动直到我们指定数量的server节点成功的加入后启动。</li></ul></li><li>-node <ul><li>作用：指定节点在集群中的名称</li><li>该名称在集群中必须是唯一的（默认采用机器的host）</li><li>推荐：直接采用机器的IP</li></ul></li><li>-bind <ul><li>作用：指明节点的IP地址</li><li>有时候不指定绑定IP，会报<code>Failed to get advertise address: Multiple private IPs found. Please configure one.</code> 的异常</li></ul></li><li>-server <ul><li>作用：指定节点为server</li><li>每个数据中心（DC）的server数推荐至少为1，至多为5</li><li>所有的server都采用raft一致性算法来确保事务的一致性和线性化，事务修改了集群的状态，且集群的状态保存在每一台server上保证可用性</li><li>server也是与其他DC交互的门面（gateway）</li></ul></li><li>-client <ul><li>作用：指定节点为client，指定客户端接口的绑定地址，包括：HTTP、DNS、RPC</li><li>默认是127.0.0.1，只允许回环接口访问</li><li>若不指定为-server，其实就是-client</li></ul></li><li>-join <ul><li>作用：将节点加入到集群</li></ul></li><li>-datacenter（老版本叫-dc，-dc已经失效） <ul><li>作用：指定机器加入到哪一个数据中心中</li></ul></li></ul><h2 id="_3-3-consul快速入门" tabindex="-1"><a class="header-anchor" href="#_3-3-consul快速入门" aria-hidden="true">#</a> 3.3 Consul快速入门</h2><p><strong>本章节场景：</strong></p><p>我们将建立两个Module，父Module是itheima-chapter-03，里面没有任何代码，它用来管理我们的聚合工程。</p><p>首先安装服务注册中心服务端Consul，然后将我们的consul-consumer、consul-provider注册到Consul服务端；</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>		&lt;module&gt;consul-consumer&lt;/module&gt;
		&lt;module&gt;consul-provider&lt;/module&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后consul-consumer通过Consul注册发现机制可以正常消费consul-provider提供的服务。</p><p>章节代码：itheima-chapter-03，工程结构如下图：</p><figure><img src="https://gaofee.cc/images/202303171135791.png" alt="1569324389195" tabindex="0" loading="lazy"><figcaption>1569324389195</figcaption></figure><h3 id="_3-3-1-consul-server安装与启动" tabindex="-1"><a class="header-anchor" href="#_3-3-1-consul-server安装与启动" aria-hidden="true">#</a> 3.3.1 Consul Server安装与启动</h3><p><strong>1) 下载</strong></p>`,64),ne={href:"https://www.consul.io/downloads.html%EF%BC%8C%E8%BF%9B%E5%85%A5%E9%A6%96%E9%A1%B5%EF%BC%8C%E9%80%89%E6%8B%A9%E5%AF%B9%E5%BA%94%E7%9A%84%E7%89%88%E6%9C%AC%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE",target:"_blank",rel:"noopener noreferrer"},ie=e("p",null,"此处以windows系统为例",-1),te=e("img",{src:"https://gaofee.cc/images/202303171135792.png",alt:"consul-version",style:{zoom:"67%"}},null,-1),re=e("p",null,[e("strong",null,"2) 解压")],-1),se=e("p",null,"将下载的安装包“consul_1.6.1_windows_amd64”进行解压，本文示例解压到D:\\consul 路径下，根据自己实际情况选择路径",-1),ae=e("p",null,[e("strong",null,"3) 安装/启动")],-1),le=e("p",null,"cmd切换到当前(consul_1.6.1_windows_amd64)目录下",-1),de=e("p",null,"执行consul.exe agent -dev 本地模式，将会使用127.0.0.1 的ip地址启动consul",-1),oe=e("p",null,[e("strong",null,"4) 访问")],-1),ce={href:"http://localhost:8500/",target:"_blank",rel:"noopener noreferrer"},ue=r(`<figure><img src="https://gaofee.cc/images/202303171135793.png" alt="consul-ui" tabindex="0" loading="lazy"><figcaption>consul-ui</figcaption></figure><h3 id="_3-3-2-consul客户端搭建" tabindex="-1"><a class="header-anchor" href="#_3-3-2-consul客户端搭建" aria-hidden="true">#</a> 3.3.2 Consul客户端搭建</h3><p><strong>1) 创建服务提供者</strong></p><p><strong>1. 创建服务提供者consul-provider</strong></p><p>向Consul注册时，它会提供有关自身的元数据，例如主机和端口，ID，名称和标签。 默认情况下会创建HTTP检查，Consul每10秒命中一次/ health端点。 如果运行状况检查失败，则将服务实例标记为严重。</p><p><strong>2. 引入起步依赖</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
			&lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;
		&lt;/dependency&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3. 修改bootstrap.yml文件</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>server:
  port: 8763
spring:
  application:
    name: consul-provider
  cloud:
    consul:
      host: localhost
      port: 8500
      discovery:
        serviceName: consul-provider
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要将上述值放在bootstrap.yml而不是application.yml中</p><p><strong>4.启动入口</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@SpringBootApplication
@EnableDiscoveryClient
public class ConsulProviderApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConsulProviderApplication.class, args);
    }

}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>5. 访问</strong></p>`,13),pe={href:"http://localhost:8500",target:"_blank",rel:"noopener noreferrer"},ge=r(`<figure><img src="https://gaofee.cc/images/202303171135794.png" alt="consul-provider-register" tabindex="0" loading="lazy"><figcaption>consul-provider-register</figcaption></figure><p>查看 Consul web 界面可以看到consul-provider已经注册到Consul服务端</p><p><strong>2) 创建服务消费者</strong></p><p>创建consul-consumer模块</p><p><strong>1. 引入起步依赖</strong></p><p>忽略，步骤同创建服务提供者。</p><p><strong>2. 修改bootstrap.yml文件</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>server:
  port: 8766
spring:
  application:
    name: consul-consumer
  cloud:
    consul:
      host: localhost
      port: 8500
      discovery:
        serviceName: consul-consumer
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3. 创建消费Controller</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@RestController
public class ConsulConsumerController {
    @Autowired
    RestTemplate restTemplate;
    @GetMapping(&quot;/hello&quot;)
    public String hello(String name) {
        return restTemplate.getForObject(&quot;http://consul-provider/hello?name=&quot; + name, String.class);
    }

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在consul-consumer中通过RestTemplate去消费服务提供者onsul-provider</p><p><strong>4. 访问</strong></p>`,12),ve={href:"http://localhost:8500",target:"_blank",rel:"noopener noreferrer"},me=e("img",{src:"https://gaofee.cc/images/202303171135795.png",alt:"consul-architecture-consumer",style:{zoom:"67%"}},null,-1),be=e("p",null,"这时，服务提供者、服务消费者注册到Consul全部成功",-1),he={href:"http://localhost:8766/hello?name=itheima%EF%BC%8C%E5%A6%82%E4%B8%8B%EF%BC%9A",target:"_blank",rel:"noopener noreferrer"},fe=r('<figure><img src="https://gaofee.cc/images/202303171135796.png" alt="consul-consumer-service" tabindex="0" loading="lazy"><figcaption>consul-consumer-service</figcaption></figure><p>可以说明，consul-consumer通过Consul注册发现可以正常消费consul-provider提供的服务</p><h2 id="_3-4-总结" tabindex="-1"><a class="header-anchor" href="#_3-4-总结" aria-hidden="true">#</a> 3.4 总结</h2><p>当前章节主要讲解了服务注册发现中心Consul，它算是Eureka闭源后的一个替代产品，在企业级应用中，Eureka逐步的被Consul和Nacos替换掉，当前章节主要说了下服务端搭建，以及客户端如何将自己注册到Consul上，它的核心功能还是以服务注册发现为主，当前章节代码有服务提供者、消费着，目的就是模拟消费者通过Consul的服务发现机制进行服务调用</p><h1 id="_4-nacos动态服务发现、配置管理" tabindex="-1"><a class="header-anchor" href="#_4-nacos动态服务发现、配置管理" aria-hidden="true">#</a> 4 Nacos动态服务发现、配置管理</h1><h2 id="_4-1-nacos概述" tabindex="-1"><a class="header-anchor" href="#_4-1-nacos概述" aria-hidden="true">#</a> 4.1 Nacos概述</h2><p><strong>1. Nacos简介</strong></p><p>Nacos（Dynamic <em>Na</em>ming and <em>Co</em>nfiguration <em>S</em>ervice） 是阿里巴巴2018年7月开源的项目，它专注于服务发现和配置管理领域 致力于帮助您发现、配置和管理微服务。Nacos 支持几乎所有主流类型的“服务”的发现、配置和管理。</p><img src="https://gaofee.cc/images/202303171135797.png" alt="nacos-architecture" style="zoom:67%;"><p><strong>2. Nacos解决了哪些问题</strong></p><p>一句话概括就是Nacos = Spring Cloud注册中心 + Spring Cloud配置中心</p><p>Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p><p>Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p><p><strong>3. Nacos与其他服务治理组件比较</strong></p><img src="https://gaofee.cc/images/202303171135798.png" alt="service-compare" style="zoom:67%;"><p><strong>4. Nacos支持主流的开源生态</strong></p><figure><img src="https://gaofee.cc/images/202303171135799.png" alt="nacos-eco" tabindex="0" loading="lazy"><figcaption>nacos-eco</figcaption></figure><blockquote><p>如 Nacos 全景图所示，Nacos 无缝支持一些主流的开源生态，例如</p><p>Kubernetes Service</p><p>gRPC &amp; Dubbo RPC Service</p><p>Spring Cloud RESTful Service</p><p>listio</p></blockquote><p>使用 Nacos 简化服务发现、配置管理、服务治理及管理的解决方案，让微服务的发现、管理、共享、组合更加容易。</p><p><strong>5. Nacos版本介绍</strong></p><p>Nacos目前最新版本为：nacos-server-1.1.3（最新稳定版）</p><p>以下是未来1年Nacos主要路线图与计划</p><p>Nacos 1.0 目标：</p><ul><li>构建简单易用的，服务相关的工具集，包括服务发现、配置管理、服务元数据存储、推送、一致性及元数据管理等；</li><li>与包括Spring Cloud、Kubernetes、Dubbo等开源生态做无缝的融合与支持，同时给这些生态带来很多面向生产时需要的优秀特性</li></ul><p>Nacos 2.0 目标：</p><p>主要关注在统一服务管理、服务共享及服务治理体系的开放的服务平台的建设上，主要包括两个方面</p><ul><li>Dubbo 4.0 + Nacos 2.0 开放的服务平台</li><li>Kubernetes + Spring Cloud 统一服务管理</li></ul><p><strong>组件版本关系</strong></p><table><thead><tr><th>Spring Cloud Alibaba Version</th><th>Sentinel Version</th><th>Nacos Version</th><th>RocketMQ Version</th><th>Dubbo Version</th><th>Seata Version</th></tr></thead><tbody><tr><td>(毕业版本) 2.1.0.RELEASE or 2.0.0.RELEASE or 1.5.0.RELEASE</td><td>1.6.3</td><td>1.1.1</td><td>4.4.0</td><td>2.7.3</td><td>0.7.1</td></tr><tr><td>(孵化器版本) 0.9.0.RELEASE or 0.2.2.RELEASE or 0.1.2.RELEASE</td><td>1.5.2</td><td>1.0.0</td><td>4.4.0</td><td>2.7.1</td><td>0.4.2</td></tr><tr><td>(孵化器版本) 0.2.1.RELEASE or 0.1.1.RELEASE</td><td>1.4.0</td><td>0.6.2</td><td>4.3.1</td><td>❌</td><td>❌</td></tr><tr><td>(孵化器版本) 0.2.0.RELEASE or 0.1.0.RELEASE</td><td>1.3.0-GA</td><td>0.3.0</td><td>❌</td><td>❌</td><td></td></tr></tbody></table><p><strong>毕业版本依赖关系(推荐使用)</strong></p><table><thead><tr><th>Spring Cloud Version</th><th>Spring Cloud Alibaba Version</th><th>Spring Boot Version</th></tr></thead><tbody><tr><td>Spring Cloud Greenwich</td><td>2.1.0.RELEASE</td><td>2.1.X.RELEASE</td></tr><tr><td>Spring Cloud Finchley</td><td>2.0.0.RELEASE</td><td>2.0.X.RELEASE</td></tr><tr><td>Spring Cloud Edgware</td><td>1.5.0.RELEASE</td><td>1.5.X.RELEASE</td></tr></tbody></table><p><strong>6. Nacos关键特性</strong></p>',32),Ee=e("p",null,[e("strong",null,"服务发现和服务健康监测")],-1),ke={href:"https://nacos.io/zh-cn/docs/sdk.html",target:"_blank",rel:"noopener noreferrer"},xe={href:"https://nacos.io/zh-cn/docs/open-API.html",target:"_blank",rel:"noopener noreferrer"},Se={href:"https://nacos.io/zh-cn/docs/other-language.html",target:"_blank",rel:"noopener noreferrer"},_e={href:"https://nacos.io/zh-cn/docs/xx",target:"_blank",rel:"noopener noreferrer"},Ce={href:"https://nacos.io/zh-cn/docs/open-API.html",target:"_blank",rel:"noopener noreferrer"},ye=e("p",null,"Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。 对于复杂的云环境和网络拓扑环境中（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了 agent 上报模式和服务端主动检测2种健康检查模式。Nacos 还提供了统一的健康检查仪表盘，帮助您根据健康状态管理服务的可用性及流量。",-1),Ae=e("p",null,[e("strong",null,"动态配置服务")],-1),Be=e("p",null,"动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置。",-1),Re=e("p",null,"动态配置消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。",-1),Ie=e("p",null,"配置中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。",-1),Ne={href:"http://console.nacos.io/nacos/index.html",target:"_blank",rel:"noopener noreferrer"},Te=e("p",null,[e("strong",null,"动态 DNS 服务")],-1),Pe=e("p",null,"动态 DNS 服务支持权重路由，让您更容易地实现中间层负载均衡、更灵活的路由策略、流量控制以及数据中心内网的简单DNS解析服务。动态DNS服务还能让您更容易地实现以 DNS 协议为基础的服务发现，以帮助您消除耦合到厂商私有服务发现 API 上的风险。",-1),we={href:"https://nacos.io/zh-cn/docs/xx",target:"_blank",rel:"noopener noreferrer"},De=e("li",null,[e("p",null,[e("strong",null,"服务及其元数据管理")]),e("p",null,"Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略、服务的 SLA 以及最首要的 metrics 统计数据。")],-1),qe=r(`<p><strong>7. Nacos监控</strong></p><p>Nacos监控是支持通过暴露metrics数据接入第三方监控系统监控Nacos运行状态</p><p>目前支持prometheus、elastic search和influxdb</p><h2 id="_4-2-nacos快速入门" tabindex="-1"><a class="header-anchor" href="#_4-2-nacos快速入门" aria-hidden="true">#</a> 4.2 Nacos快速入门</h2><p><strong>本章节场景：</strong></p><p>我们将建立两个Module（注册发现是一个大Module，如下图），父Module是itheima-chapter-04，里面没有任何代码，它用来管理我们的聚合工程。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>		&lt;module&gt;nacos-spring-cloud-config-example&lt;/module&gt;
		&lt;module&gt;nacos-spring-cloud-discovery-example&lt;/module&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>首先我们下载安装Nacos Server，它用来作为服务注册中心和配置中心</p><p>场景一：作为注册发现，将我们的nacos-spring-cloud-consumer-example、nacos-spring-cloud-discovery-example注册到Nacos上实现远程调用</p><p>场景二：nacos-spring-cloud-config-example作为配置中心，在Nacos Server通过API发布配置,通过/config/get获取Nacos配置信息，然后在修改Nacos Server上的配置信息，然后通过nacos-spring-cloud-config-example下的/config/get获取最新修改后的值，实现自动刷新功能</p><p>章节将采取Nacos进行服务注册、服务发现、配置管理，章节代码：itheima-chapter-04，工程结构如下图：</p><figure><img src="https://gaofee.cc/images/202303171135800.png" alt="1570584510796" tabindex="0" loading="lazy"><figcaption>1570584510796</figcaption></figure><h3 id="_4-2-1-nacos-server安装与启动" tabindex="-1"><a class="header-anchor" href="#_4-2-1-nacos-server安装与启动" aria-hidden="true">#</a> 4.2.1 Nacos Server安装与启动</h3><p><strong>1) 预备环境准备</strong></p>`,14),Le={href:"https://docs.oracle.com/cd/E19182-01/820-7851/inst_cli_jdk_javahome_t/",target:"_blank",rel:"noopener noreferrer"},Oe={href:"https://maven.apache.org/index.html",target:"_blank",rel:"noopener noreferrer"},Me=r(`<ol><li>64 bit OS，支持 Linux/Unix/Mac/Windows，推荐选用 Linux/Unix/Mac。</li><li>64 bit JDK 1.8+；</li><li>Maven 3.2.x+；</li></ol><p><strong>2) Nacos下载</strong></p><p>你可以通过源码和发行包两种方式来获取 Nacos。</p><p><strong>从 Github 上下载源码方式</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> clone https://github.com/alibaba/nacos.git
<span class="token builtin class-name">cd</span> nacos/
mvn -Prelease-nacos clean <span class="token function">install</span> <span class="token parameter variable">-U</span>  
<span class="token function">ls</span> <span class="token parameter variable">-al</span> distribution/target/

// change the <span class="token variable">$version</span> to your actual path
<span class="token builtin class-name">cd</span> distribution/target/nacos-server-<span class="token variable">$version</span>/nacos/bin
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>下载压缩包方式</strong></p>`,6),ze={href:"https://github.com/alibaba/nacos/releases%E4%B8%8B%E8%BD%BD%60nacos-server-$version.zip%60",target:"_blank",rel:"noopener noreferrer"},Fe=r(`<p><strong>3) Nacos启动</strong></p><p><strong>Linux/Unix/Mac</strong></p><p>启动命令(standalone代表着单机模式运行，非集群模式):</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>sh startup.sh -m standalone
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果您使用的是ubuntu系统，或者运行脚本报错提示[[符号找不到，可尝试如下运行：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>bash startup.sh -m standalone
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>Windows</strong></p><p>启动命令：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>cmd startup.cmd
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或者双击startup.cmd运行文件（<strong>如果cmd窗口闪一下就没有了，请在startup.cmd设置JAVA_HOME</strong>）。</p><p>启动成功如下图：</p><figure><img src="https://gaofee.cc/images/202303171135801.png" alt="nacos-run" tabindex="0" loading="lazy"><figcaption>nacos-run</figcaption></figure><p><strong>4) Nacos访问</strong></p>`,13),He={href:"http://localhost:8848/nacos/",target:"_blank",rel:"noopener noreferrer"},Ue=r(`<img src="https://gaofee.cc/images/202303171135802.png" alt="nacos-login" style="zoom:67%;"><p>输入默认用户名：nacos 密码：nacos (如果要修改默认的用户名密码，需要按照mysql)</p><p>登陆成功界面如下</p><img src="https://gaofee.cc/images/202303171135803.png" alt="nacos-home" style="zoom:67%;"><p><strong>5) Nacos关闭</strong></p><p><strong>Linux/Unix/Mac</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>sh shutdown.sh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>Windows</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>cmd shutdown.cmd
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或者双击shutdown.cmd运行文件。</p><h3 id="_4-2-2-nacos-client自动刷新" tabindex="-1"><a class="header-anchor" href="#_4-2-2-nacos-client自动刷新" aria-hidden="true">#</a> 4.2.2 Nacos Client自动刷新</h3><p><strong>1) 创建nacos-spring-cloud-config-example模块</strong></p><p>与Spring Cloud集成，创建自动刷新模块nacos-spring-cloud-config-example</p><p><strong>2) 引入起步依赖</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;
    &lt;version&gt;\${latest.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3) 配置bootstrap.properties</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>spring.cloud.nacos.config.server-addr=127.0.0.1:8848
spring.application.name=example
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>配置 Nacos server 的地址和应用名</p><p>说明：之所以需要配置 <code>spring.application.name</code> ，是因为它是构成 Nacos 配置管理 <code>dataId</code>字段的一部分。</p><p>在 Nacos Spring Cloud 中，<code>dataId</code> 的完整格式如下</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>\${prefix}-\${spring.profile.active}.\${file-extension}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,21),We=e("ul",null,[e("li",null,[e("code",null,"prefix"),n(" 默认为 "),e("code",null,"spring.application.name"),n(" 的值，也可以通过配置项 "),e("code",null,"spring.cloud.nacos.config.prefix"),n("来配置。")]),e("li",null,[e("code",null,"spring.profile.active"),n(" 即为当前环境对应的 profile， "),e("strong",null,[n("注意：当 spring.profile.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 "),e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("semantics",null,[e("mrow",null,[e("mrow",null,[e("mi",null,"p"),e("mi",null,"r"),e("mi",null,"e"),e("mi",null,"f"),e("mi",null,"i"),e("mi",null,"x")]),e("mi",{mathvariant:"normal"},".")]),e("annotation",{encoding:"application/x-tex"},"{prefix}.")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.8889em","vertical-align":"-0.1944em"}}),e("span",{class:"mord"},[e("span",{class:"mord mathnormal"},"p"),e("span",{class:"mord mathnormal"},"re"),e("span",{class:"mord mathnormal",style:{"margin-right":"0.10764em"}},"f"),e("span",{class:"mord mathnormal"},"i"),e("span",{class:"mord mathnormal"},"x")]),e("span",{class:"mord"},".")])])]),n("{file-extension}")])]),e("li",null,[e("code",null,"file-exetension"),n(" 为配置内容的数据格式，可以通过配置项 "),e("code",null,"spring.cloud.nacos.config.file-extension"),n(" 来配置。目前只支持 "),e("code",null,"properties"),n(" 和 "),e("code",null,"yaml"),n(" 类型")])],-1),je=r(`<p><strong>4) 实现自动更新</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@RestController
@RequestMapping(&quot;/config&quot;)
@RefreshScope
public class ConfigController {

    @Value(&quot;\${useLocalCache:false}&quot;)
    private boolean useLocalCache;

    @RequestMapping(&quot;/get&quot;)
    public boolean get() {
        return useLocalCache;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 Spring Cloud 原生注解 <code>@RefreshScope</code> 实现配置自动更新</p><p><strong>5) 发布配置</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>curl -X POST &quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=example.properties&amp;group=DEFAULT_GROUP&amp;content=useLocalCache=true&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://gaofee.cc/images/202303171135804.png" alt="1569031985609" tabindex="0" loading="lazy"><figcaption>1569031985609</figcaption></figure><p><strong>6) 访问</strong></p><p>运行 <code>NacosConfigApplication</code>，调用 <code>curl http://localhost:8080/config/get</code>，返回内容是 <code>true</code></p><figure><img src="https://gaofee.cc/images/202303171135805.png" alt="1569032013832" tabindex="0" loading="lazy"><figcaption>1569032013832</figcaption></figure><p><strong>7) 再次发布配置</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>curl -X POST &quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=example.properties&amp;group=DEFAULT_GROUP&amp;content=useLocalCache=false&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>8) 再次访问</strong></p><p>再次访问 <code>http://localhost:8080/config/get</code>，此时返回内容为<code>false</code>，说明程序中的<code>useLocalCache</code>值已经被动态更新了</p><figure><img src="https://gaofee.cc/images/202303171135806.png" alt="1569032138053" tabindex="0" loading="lazy"><figcaption>1569032138053</figcaption></figure><h3 id="_4-2-3-nacos-client服务注册发现" tabindex="-1"><a class="header-anchor" href="#_4-2-3-nacos-client服务注册发现" aria-hidden="true">#</a> 4.2.3 Nacos Client服务注册发现</h3><p><strong>1) 创建服务提供者模块</strong></p><p>与Spring Cloud集成，工程为nacos-spring-cloud-provider-example</p><p><strong>2) 引入起步依赖</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
    &lt;version&gt;\${latest.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3) 配置服务提供者</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>server.port=8070
spring.application.name=service-provider
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 <code>application.properties</code> 中配置 Nacos server 的地址,,可以通过 Nacos 的服务注册发现功能将其服务注册到 Nacos server 上</p><p><strong>4) 开启服务注册发现功能</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@SpringBootApplication
@EnableDiscoveryClient
public class NacosProviderApplication {

    public static void main(String[] args) {
        SpringApplication.run(NacosProviderApplication.class, args);
    }

    @RestController
    class EchoController {
        @RequestMapping(value = &quot;/echo/{string}&quot;, method = RequestMethod.GET)
        public String echo(@PathVariable String string) {
            return &quot;Hello Nacos Discovery &quot; + string;
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 <code>application.properties</code> 中配置 Nacos server 的地址，从而服务消费者可以通过 Nacos 的服务注册发现功能从 Nacos server 上获取到它要调用的服务</p><p><strong>5) 创建服务消费者模块</strong></p><p>与Spring Cloud集成，工程为nacos-spring-cloud-consumer-example</p><p><strong>7) 引入起步依赖</strong></p><p>同服务提供者一样配置，此处不再赘述</p><p><strong>8) 配置服务消费者</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>server.port=8080
spring.application.name=service-consumer
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>9) 开启服务注册发现功能</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@SpringBootApplication
@EnableDiscoveryClient
public class NacosConsumerApplication {

    public static void main(String[] args) {
        SpringApplication.run(NacosConsumerApplication.class, args);
    }

    @LoadBalanced
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }

    @RestController
    public class TestController {

        private final RestTemplate restTemplate;

        @Autowired
        public TestController(RestTemplate restTemplate) {
            this.restTemplate = restTemplate;
        }

        @RequestMapping(value = &quot;/echo/{str}&quot;, method = RequestMethod.GET)
        public String echo(@PathVariable String str) {
            return restTemplate.getForObject(&quot;http://service-provider/echo/&quot; + str, String.class);
        }
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 Spring Cloud 原生注解 @EnableDiscoveryClient 开启服务注册发现功能。给 RestTemplate 实例添加 @LoadBalanced 注解，开启 @LoadBalanced 与 Ribbon 的集成</p><p><strong>7) 启动</strong></p><p>启动 nacos-spring-cloud-discovery-example下的<code>ProviderApplication</code> 和 <code>ConsumerApplication</code></p><figure><img src="https://gaofee.cc/images/202303171135807.png" alt="1570584542615" tabindex="0" loading="lazy"><figcaption>1570584542615</figcaption></figure><p>由上图可知，我们的生产者和消费者都注册到了Nacos Server上了</p><p>调用 <code>http://localhost:8080/echo/itheima</code></p><p>返回内容为 \`Hello Nacos Discovery itheima,说明我们从Naoos成功的消费了，如下图：</p><figure><img src="https://gaofee.cc/images/202303171135808.png" alt="nacos-consumer" tabindex="0" loading="lazy"><figcaption>nacos-consumer</figcaption></figure><h2 id="_4-3-总结" tabindex="-1"><a class="header-anchor" href="#_4-3-总结" aria-hidden="true">#</a> 4.3 总结</h2><p>当前章节主要介绍了Nacos的一些核心功能，比如它具备服务注册发现和配置中心的功能，由此可见，Nacos具备了Spirng Cloud生态中两个高级组件的组合功能，Eureka+Hystrix在Nacos中都可以实现。</p><p>随着Eureka闭源,Nacos会慢慢的逐步替代之前的服务注册发现中心，在代码中，详细的讲解了如何进行启动和配置Nacos，以及通过代码的方式实现服务注册发现和配置中心</p><h1 id="_5-ribbon客户端负载均衡" tabindex="-1"><a class="header-anchor" href="#_5-ribbon客户端负载均衡" aria-hidden="true">#</a> 5 Ribbon客户端负载均衡</h1><h2 id="_5-1-ribbon概述" tabindex="-1"><a class="header-anchor" href="#_5-1-ribbon概述" aria-hidden="true">#</a> 5.1 Ribbon概述</h2><p><strong>1. Ribbon简介</strong></p><p>Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它内部提供了一个叫做ILoadBalance的接口代表负载均衡器的操作，基于Netflix Ribbon实现。通过Spring Cloud的封装，可以让我们轻松地将面向服务的REST模版请求自动转换成客户端负载均衡的服务调用，Ribbon有两种使用方式:一种是和RestTemplate结合、一种是和Feign(已集成）相结合</p><p>Ribbon 有很多子模块，但很多模块没有用于生产环境，目前Netflix 公司用于生产环境的Ribbon子模块如下。</p><pre><code>    Ribbon-loadbalancer：可以独立使用或与其他模块一起使用的负载均衡器API 。
    Ribbon-eureka ：阳bbon 结合Eureka 客户端的API ，为负载均衡器提供动态服务注册列表信息。
    Ribbon-core: Ribbon 的核心API 。
</code></pre><p><strong>2. 工作原理</strong></p><img src="https://gaofee.cc/images/202303171135809.png" alt="ribbon-work-flow" style="zoom:50%;"><p><strong>3. 负载均衡策略</strong></p><ol><li>随机 (Random)</li><li>轮询 (RoundRobin)</li><li>一致性哈希 (ConsistentHash)</li><li>哈希 (Hash)</li><li>加权（Weighted）</li></ol><p><strong>4. 解决了哪些问题</strong></p><p>负载均衡是用于解决一台机器(一个进程)无法解决所有请求而产生的一种算法。像nginx可以使用负载均衡分配流量</p><p>集群里的1台或者多台服务器down的时候，剩余的没有down的服务器可以保证服务的继续使用</p><p>使用了更多的机器保证了机器的良性使用，不会由于某一高峰时刻导致系统cpu急剧上升</p><h2 id="_5-2-深入理解" tabindex="-1"><a class="header-anchor" href="#_5-2-深入理解" aria-hidden="true">#</a> 5.2 深入理解</h2><p><strong>1. RestTemplate介绍</strong></p><p>RestTemplate是Spring Web模块提供的一个基于Rest规范提供Http请求的工具。 Ribbon是Spring Cloud中客户端负载均衡的组件。我们在微服务架构中，往往通过RestTemplate发送RPC请求，然后通过Ribbon做客户端负载均衡，通过硬编码的形式在方法上加入元注解@LoadBalanced，当一个被@LoadBalanced注解修饰的RestTemplate对象向外发起HTTP请求时，就赋予了负载均衡的能力</p><p><strong>2 LoadBalancerClient介绍</strong></p><p>LoadBalancerClient，客户端侧的负载均衡器。它 是一个接口，继承了ServiceInstanceChooser</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>public interface LoadBalancerClient extends ServiceInstanceChooser {
    &lt;T&gt; T execute(String serviceId, LoadBalancerRequest&lt;T&gt; request) throws IOException;

    &lt;T&gt; T execute(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request) throws IOException;

    URI reconstructURI(ServiceInstance instance, URI original);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>public interface ServiceInstanceChooser {
    ServiceInstance choose(String serviceId);
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从该接口中，我们可以通过定义的抽象方法来了解到客户端负载均衡器中应具备的几种能力：</p><p>1、ServiceInstance choose(String serviceId)：根据传入的服务名serviceId，从负载均衡器中挑选一个对应服务的实例。</p><p>2、T execute(String serviceId, LoadBalancerRequest request) throws IOException：使用从负载均衡器中挑选出的服务实例来执行请求内容。</p><p>3、T execute(String serviceId, ServiceInstance serviceInstance,LoadBalancerRequest request,) throws IOException：使用从负载均衡器中挑选出的服务实例来执行请求内容。</p><p>4、URI reconstructURI(ServiceInstance instance, URI original)：为系统构建一个合适的“host:port”形式的URI。</p><h2 id="_5-3-ribbon快速入门" tabindex="-1"><a class="header-anchor" href="#_5-3-ribbon快速入门" aria-hidden="true">#</a> 5.3 Ribbon快速入门</h2><p><strong>本章节场景：</strong></p><p>我们将建立四个Module，父Module是itheima-chapter-05，里面没有任何代码，它用来管理我们的聚合工程。</p><p>eureka-client-ribbon、eureka-client-ribbon-backup、eureka-server-ribbon是服务注册中心服务端和服务注册中心客户端，代码直接复制第二章节Eureka章节itheima-chapter-02的代码，只是修改了Module名字，其他没有做任何改变，ribbon-client是负载均衡的实现</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>		&lt;module&gt;ribbon-client&lt;/module&gt;
		&lt;module&gt;eureka-client-ribbon&lt;/module&gt;
		&lt;module&gt;eureka-client-ribbon-backup&lt;/module&gt;
		&lt;module&gt;eureka-server-ribbon&lt;/module&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>具体场景：</strong></p><p>将eureka-client-ribbon、eureka-client-ribbon-backup注册到服务端eureka-server-ribbon</p><p>然后通过ribbon-client调用eureka-client-ribbon、eureka-client-ribbon-backup上的api，实现负载均衡</p><p>本章节将采取Ribbon进行客户端负载均衡，章节代码：itheima-chapter-05，工程结构如下图：</p><figure><img src="https://gaofee.cc/images/202303171135810.png" alt="1570584565457" tabindex="0" loading="lazy"><figcaption>1570584565457</figcaption></figure><p><strong>5.3.1 创建负载均衡</strong></p><p>创建负载均衡客户端模块ribbon-client</p><p><strong>1. 引入起步依赖</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>       &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2. 修改application.yml文件</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>spring:
  application:
     name: ribbon-client
 server:
   port: 8764
   eureka:
      client:
        service-url:
          defaultZone: http://localhost:8761/eureka/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3. 增加配置类RibbonConfig</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@Configuration
public class RibbonConfig {

    /**
     * 在此类中为IoC容器中注入一个RestTemplate的Bean,并在这个Bean 上
       加上@LoadBalanced 注解，此时RestTemplate 就结合了Ribbon 开启了负载均衡功能
     *
     */
    @Bean
    @LoadBalanced
    RestTemplate restTemplate() {
        return new RestTemplate();
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>新建一个RibbonConfig加上@Configuration注解，标识此类为配置类，当前配置类的作用主要是定义RestTemplate的负载均衡的能力</p><p><strong>4. 增加RibbonService</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@Service
public class RibbonService {

    @Autowired
    RestTemplate restTemplate;

    /**
     * 在该类的helllo方法用restTemplate调用eureka-client的API接口  Uri 上不需要使用硬编码（比如IP），只需要        写服务名eureka-client即可
     * 程序会根据服务名称 eureka-client到Eureka-server注册中心去自动获取IP和端口信息。
     * @param name
     * @return
     */
    public String helllo(String name) {
        return restTemplate.getForObject(&quot;http://eureka-client/hello?name=&quot;+name,String.class);
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>5. 增加RibbonController</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>   @GetMapping(&quot;/hello&quot;)
    public String hello(@RequestParam(required = false,defaultValue = &quot;itheima&quot;) String name){
        return ribbonService.hello(name);
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>RibbonController类，为该类加上＠RestController 注解，开启RestController 的功能，使用&quot;/hello&quot; Get 方法的接口，调用RibbonService 类的hello（）方法</p><p><strong>6. 启动</strong></p><p>在访问前依次启动eureka-server-ribbon、ribbon-client、eureka-client-ribbon、eureka-client-ribbon-backup</p><figure><img src="https://gaofee.cc/images/202303171135811.png" alt="1570584581160" tabindex="0" loading="lazy"><figcaption>1570584581160</figcaption></figure><p><strong>7. 访问</strong></p>`,98),Ge={href:"http://localhost:8764/hello?name=itheima%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A",target:"_blank",rel:"noopener noreferrer"},Ke=r(`<figure><img src="https://gaofee.cc/images/202303171135812.png" alt="ribbon-test" tabindex="0" loading="lazy"><figcaption>ribbon-test</figcaption></figure><p><strong>输出显示如下：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>hi itheima,i am from port:8762

hi itheima,i am from port:8763
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由此可见，网页上的数据会轮流显示，说明我们的ribbon-client代码达到了负载均衡的效果（默认轮询策略）</p><h2 id="_5-4-总结" tabindex="-1"><a class="header-anchor" href="#_5-4-总结" aria-hidden="true">#</a> 5.4 总结</h2><p>当前章节主要介绍了负载均衡原理，以及解决了那些实际问题，比如分配流量，在代码中详细的讲解了通过RestTemlate的方式调用远程两个服务eureka-client-ribbon、eureka-client-ribbon-backup的api接口，由于消费端ribbon-client开启了负载均衡策略，所以在进行RPC调用的时候浏览器的输出是轮流显示，说明达到了负载均衡的目的</p>`,6);function Ve(Ze,Xe){const i=d("ExternalLinkIcon");return a(),l("div",null,[c,e("p",null,[n('​ "微服务”一词源于 Martin Fowler的名为 Microservices的,博文,可以在他的官方博客上找到'),e("a",u,[n("http://martinfowler.com/articles/microservices.html简单地说,微服务是系统架构上的一种设计风格,它的主旨是将一个原本独立的系统拆分成多个小型服务,这些小型服务都在各自独立的进程中运行,服务之间通过基于HTTP的"),t(i)]),n(" RESTfuL AP进行通信协作。被拆分成的每一个小型服务都围绕着系统中的某一项或些耦合度较高的业务功能进行构建,并且每个服务都维护着白身的数据存储、业务开发自动化测试案例以及独立部署机制。由于有了轻量级的通信协作基础,所以这些微服务可以使用不同的语言来编写。")]),p,e("p",null,[n("Spring Cloud项目官方网址："),e("a",g,[n("https://spring.io/projects/spring-cloud"),t(i)])]),v,e("ul",null,[m,e("li",null,[b,h,e("p",null,[n("Nagios是一款开源的免费网络监视工具，能有效监控Windows、Linux和Unix的"),e("a",f,[n("主机"),t(i)]),n("状态，交换机"),e("a",E,[n("路由器"),t(i)]),n("等网络设备，打印机等。在系统或服务状态异常时发出邮件或短信报警第一时间通知网站运维人员，在状态恢复后发出正常的邮件或短信通知。")]),k,x,S,_,C,e("p",null,[n("5、具备定义"),e("a",y,[n("网络分层"),t(i)]),n('结构的能力，用"parent"主机定义来表达网络主机间的关系，这种关系可被用来发现和明晰主机宕机或不可达状态；')]),e("p",null,[n("6、当服务或"),e("a",A,[n("主机"),t(i)]),n("问题产生与解决时将告警发送给联系人（通过EMail、短信、用户定义方式）；")]),B,R,e("p",null,[n("9、可以支持并实现对主机的"),e("a",I,[n("冗余"),t(i)]),n("监控；")]),N,T,P])]),w,e("p",null,[D,n("上图来自官方的言论，( "),e("a",q,[n("https://github.com/Netflix/eureka/wiki"),t(i)]),n(")")]),L,e("p",null,[n("浏览器地址栏输入 "),e("a",O,[n("http://localhost:8761/"),t(i)]),n(" 运行效果如下：")]),M,e("p",null,[n("浏览器地址栏输入 "),e("a",z,[n("http://localhost:8761/"),t(i)])]),F,e("p",null,[n("上面的配置文件"),H,n("就是defaultZone: "),e("a",U,[n("http://eureka2:8888/eureka/"),t(i)])]),W,e("p",null,[n("上面的配置文件"),j,n("就是defaultZone: "),e("a",G,[n("http://eureka1:8888/eureka/"),t(i)])]),K,e("p",null,[n("我们将客户端注册到了 defaultZone: "),e("a",V,[n("http://eureka1:7777/eureka/，这个eureka1就是我们在Hosts文件中配置的映射"),t(i)])]),Z,e("p",null,[n("浏览器地址栏输入"),e("a",X,[n("http://localhost:8888/和http://localhost:7777/，如下图："),t(i)])]),$,e("p",null,[n("5、停掉集群中的一个节点，查看服务是否正常访问 "),e("a",J,[n("http://localhost:9999/itheima?name=itheima"),t(i)])]),Y,e("p",null,[n("浏览器输入"),e("a",Q,[n("http://localhost:8888/或者http://localhost:7777都会要求输入用户名密码，这样的话，我们的Eureka服务器就受到了保护"),t(i)])]),ee,e("p",null,[n("官网下载地址："),e("a",ne,[n("https://www.consul.io/downloads.html，进入首页，选择对应的版本，如下图"),t(i)])]),ie,te,re,se,ae,le,de,oe,e("p",null,[n("浏览器输入 "),e("a",ce,[n("http://localhost:8500/"),t(i)]),n(" 即可访问Consul，如下图")]),ue,e("p",null,[n("启动consul-provider，打开浏览器"),e("a",pe,[n("http://localhost:8500"),t(i)])]),ge,e("p",null,[n("启动consul-consumer，打开浏览器"),e("a",ve,[n("http://localhost:8500"),t(i)]),n("，如下：")]),me,be,e("p",null,[n("执行"),e("a",he,[n("http://localhost:8766/hello?name=itheima，如下："),t(i)])]),fe,e("ul",null,[e("li",null,[Ee,e("p",null,[n("Nacos 支持基于 DNS 和基于 RPC 的服务发现。服务提供者使用 "),e("a",ke,[n("原生SDK"),t(i)]),n("、"),e("a",xe,[n("OpenAPI"),t(i)]),n("、或一个"),e("a",Se,[n("独立的Agent TODO"),t(i)]),n("注册 Service 后，服务消费者可以使用"),e("a",_e,[n("DNS TODO"),t(i)]),n(" 或"),e("a",Ce,[n("HTTP&API"),t(i)]),n("查找和发现服务。")]),ye]),e("li",null,[Ae,Be,Re,Ie,e("p",null,[n("Nacos 提供了一个简洁易用的UI ("),e("a",Ne,[n("控制台样例 Demo"),t(i)]),n(") 帮助您管理所有的服务和应用的配置。Nacos 还提供包括配置版本跟踪、金丝雀发布、一键回滚配置以及客户端配置更新状态跟踪在内的一系列开箱即用的配置管理特性，帮助您更安全地在生产环境中管理配置变更和降低配置变更带来的风险。")])]),e("li",null,[Te,Pe,e("p",null,[n("Nacos 提供了一些简单的 "),e("a",we,[n("DNS APIs TODO"),t(i)]),n(" 帮助您管理服务的关联域名和可用的 IP:PORT 列表.")])]),De]),qe,e("p",null,[n("Nacos 依赖 "),e("a",Le,[n("Java"),t(i)]),n(" 环境来运行。如果您是从代码开始构建并运行Nacos，还需要为此配置 "),e("a",Oe,[n("Maven"),t(i)]),n("环境，请确保是在以下版本环境中安装使用:")]),Me,e("p",null,[n("您可以从 "),e("a",ze,[n("https://github.com/alibaba/nacos/releases下载`nacos-server-$version.zip`"),t(i)]),n(" 包。")]),Fe,e("p",null,[n("浏览器访问"),e("a",He,[n("http://localhost:8848/nacos/"),t(i)])]),Ue,We,je,e("p",null,[n("在浏览器输入"),e("a",Ge,[n("http://localhost:8764/hello?name=itheima如下图："),t(i)])]),Ke])}const Je=s(o,[["render",Ve],["__file","day01-SpringCloud第一阶段.html.vue"]]);export{Je as default};
